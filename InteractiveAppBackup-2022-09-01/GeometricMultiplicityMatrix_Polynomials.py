

# This file was *autogenerated* from the file GeometricMultiplicityMatrix_Polynomials.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_2p0 = RealNumber('2.0')###### Imports ######
from Rep_Sage_lib import *
import numpy as np
from IPython.display import display, Markdown, Latex
from itertools import combinations_with_replacement as cwr
from itertools import product as cart_prod


#################################################### Rank Triangle ####################################################


class Rank_Triangle:
    """
    A class used to symbolically represent a rank triangle associated with orbits in Vogan
    varieties for GLn

    ...

    Attributes
    ----------
    array : array
        an array storing the rank triangle in the lower triangular region
    eigen_list : list
        a list of eigenvalues for the Vogan Variety
    hash_triag : tuple
        a tuple encoding the rank triangle for storing

    Methods
    -------
    get_array()
        returns a copy of the rank triangle array
    get_inf()
        returns a copy of the infinitesimal parameter eigen list
    get_length()
        returns the size of GLN we are representing
    """
    
    
    def __init__(self, multisegment):
        """
        Initializes the rank triangle using a multisegment and the rank_triag function
        """
        
        # Initialize array and eigenvalue list associated with the rank triangle
        self.array, self.eigen_list = rank_triag(multisegment)
        
        # Initializes a tuple of rank triangle elements going left to right, top row to bottom row
        self.hash_triag = tuple([int(self.array[i+j,j]) for i in range(_sage_const_1 ,self.array.shape[_sage_const_0 ]) for j in range(_sage_const_0 ,self.array.shape[_sage_const_0 ]-i)])
        
    
    def __hash__(self):
        """
        Defines the hash for a rank triangle
        """
        return hash(self.hash_triag)
    
    def __eq__(self, other):
        """
        Defines when two rank triangles are equal
        
        Parameters
        ----------
        other : rank triangle
            the rank triangle being compared with
        """
        # If the two multisegments have the same dictionary then they are equal
        eq_array = other.get_array() == self.get_array()
        
        if eq_array.all() and other.get_inf() == self.get_inf():
            return True
        else:
            return False
    
    
    def __ne__(self, other):
        """
        Defines when two rank triangles are not equal
        
        Parameters
        ----------
        other : rank triangle
            the rank triangle being compared with
        """
        
        return not self.__eq__(other)
    
    
    def __lt__(self, other):
        """
        Defines when a rank triangle is less than another
        
        Parameters
        ----------
        other : rank triangle
            the rank triangle being compared with
        """
        comparatorAny = self.get_array() < other.get_array()
        comparatorAll = self.get_array() <= other.get_array()
        return comparatorAll.all() and comparatorAny.any()
        
    def __le__(self, other):
        """
        Defines when a rank triangle is less than or equal to another
        
        Parameters
        ----------
        other : rank triangle
            the rank triangle being compared with
        """
        
        comparatorAll = self.get_array() <= other.get_array()
        return comparatorAll.all()
    
        
    def get_array(self):
        """
        Returns a copy of the array storing the rank triangle
        """
        
        return copy(self.array)
    
    def get_inf(self):
        """
        Returns a copy of the eigenvalue list
        """
        return copy(self.eigen_list)
    
    def get_length(self):
        """
        Returns the length of the eigenlist
        """
        return len(self.eigen_list)
    
    def __repr__(self):
        """
        Represent a rank triangle as a list of the segment representations
        """
        
        repr_str = "C"+str(self.hash_triag)
        
        return repr_str
    
    def __str__(self):
        """
        Shows the string representation of the multisegment when asked to print it
        """
        
        return array_to_triag(self.get_array(),self.eigen_list)
        
        
def order(rank1, rank2):
    """
    Returns if rank1 is <= to rank2 for poset orderings

    Parameters
    ----------
    rank1 : rank triangle
        the rank triangle on the left hand side of the relation
    rank2 : rank triangle
        the rank triangle on the right hand side of the relation
    """
    return rank1 <= rank2



#################################################### Smoothness ####################################################

def rank_str_input(rank_triang_array):
    """
    Obtain the input string corresponding with a rank triangle and eigenvalue list

    Parameters
    ----------
    rank_triang_array : array
        an array containing rank triangle data in its lower triangular region
    """
    
    # Initialze row number
    row_num = np.shape(rank_triang_array)[_sage_const_0 ]
    
    output_str = ""
    # Creates the string associated with the rank triangle stored in the lower triangular portion of the matrix
    for i in range(row_num):
        # Joins the integers on the ith diagonal below the main diagonal
        cur_str = ','.join([str(int(j)) for j in np.diag(rank_triang_array, k = -i)])
        cur_str = '{' + cur_str + '}'
        
        # Add the current string to the output
        output_str += cur_str
        
        # Add an ending or starting brace if we are at the start or end of the input, or add a comma
        if i == _sage_const_0 :
            output_str += ','+'{'
        elif i != row_num-_sage_const_1 :
            output_str += ','
        else:
            output_str += '}'
    
    # Return the rank triangle string
    return output_str
    
    
def isSmooth(orbit, dim_orbit, dim_space):
    """
    Returns whether an orbit is smooth or not using its ideal equations computed in VoganV.m2

    Parameters
    ----------
    orbit : rank triangle
        the rank triangle to be tested for smoothness
    dim_orbit : int
        the integer dimension of the orbit
    dim_space : int
        the integer dimension of the ambient Vogan variety
    """
    
    # Loads VoganV, gets the input string from the array, and computes the rank of its Jacobian at 0
    macaulay2.eval("""
    needs "VoganV.m2";
    """)
    input_str = rank_str_input(orbit.get_array())
    input_str = r"orbit := new RankConditions from (" + input_str + r");"
    macaulay2.eval(input_str)
    macaulay2.eval("""
        E = getEquations orbit
        J = jacobian E
        L = substitute(J, 0)
        d = rank L
    """)
    rank = macaulay2("d")
    
    # If the rank is >= dim_space - dim_orbit it is smooth, otherwise it is not
    if rank >= dim_space - dim_orbit:
        return True
    else:
        return False
        
        
        

#################################################### Resolutions ####################################################



def resolve(orbit, rankTriags, restr_dict, dim_dict, pos, t):
    """
    Computes the IC stalk shifts for the singular orbit inputted using
    a resolution of singularities

    Parameters
    ----------
    orbit : rank triangle
        singular orbit to be resolved
    rankTriangs : set
        a set of orbits in the current Vogan
    restr_dict : dict
        dictionary of IC stalk shifts already computed for other orbits in the Vogan
    dim_dict : dict
        dictionary of dimensions of orbits
    pos : Poset
        Poset of orbits using the standard closure ordering
    """
    
    # Set the shift of the trivial IC at the orbit to 1 (by defining property of an IC)
    restr_dict[orbit][orbit] += t**(dim_dict[orbit])
    
    # Initialize list of rank triangles less than the current orbit, a dictionary of fibers for all C
    # in the list, and a dictionary of fiber dimensions
    iter_list = {C for C in rankTriags if C < orbit}
    fibers = dict([(C,_sage_const_0 *t) for C in iter_list])
    dim_fibers = dict([(C,_sage_const_0 ) for C in iter_list])
    
    # Computes all of the fibers and fiber dimensions
    for C in iter_list:
        fibers[C], dim_fibers[C] = fiber(orbit, C, dim_dict, t)
        if dim_fibers[C] == -_sage_const_1 :
            return -_sage_const_1 
        
    # Initializes the defect of the resolution at 0
    defect = _sage_const_0 
    
    # Computes the defect of the resolution by taking the max of over all orbits
    for C in iter_list:
        defect = max(defect, int(dim_dict[C])+_sage_const_2 *int(dim_fibers[C]) - int(dim_dict[orbit]))
   
    # If defect > 0 go to the non-semi-small case, otherwise we can use the semi-small case
    if defect > _sage_const_0 :
        non_semi_small(orbit, restr_dict, dim_dict, fibers, defect, pos, t)
    elif defect == _sage_const_0 :
        semi_small(orbit, restr_dict, dim_dict, fibers, pos, t)
        
        
        
def non_semi_small(orbit, restr_dict, dim_dict, fibers, defect, pos, t):
    """
    Computes the IC stalk shifts for the singular orbit inputted using
    the current non-semi-small resolution of singularities

    Parameters
    ----------
    orbit : rank triangle
        singular orbit to be resolved
    restr_dict : dict
        dictionary of IC stalk shifts already computed for other orbits in the Vogan
    dim_dict : dict
        dictionary of dimensions of orbits
    fibers : dict
        dictionary of fibers in the resolution for all orbits less than the current one
    defect : int
        the integer defect of the resolution
    pos : Poset
        Poset of orbits using the standard closure ordering
    """
    
    # Initialize dictionary of multiplicities, where each value is a dictionary which
    # will contain shifts as keys and multiplicities of shifts as values
    multiplicities = dict([(C,_sage_const_0 *t) for C in fibers.keys()])
    
    # Initialize set of orbits with computed multiplicities
    computed = set()
    
    # Initialize list of orbits we will take the lower cover of
        # Note that this follows a process of "inverse induction" in the sense that
        # we find multiplicities for the largest orbits first then move down to their next level
    cover_list = {orbit}
    
    # Initialize the set of orbits to be skipped on a given iteration
    next_step = set()
    
    # Iterates until all orbits in the fibers dictionary are computed
    while computed != set(fibers.keys()):
        
        # Initializes list of orbits to compute multiplicities of in this iteration
        iter_list = next_step.union({C for C2 in cover_list 
                                     for C in pos.lower_covers(C2) if not C in computed})
        # Reset next step set to be empty
        next_step = set()
        
        for C in iter_list:
            # Initializes the interval of orbits bewtween the current one and our orbit of interest
            # to ensure there are no larger orbits which have not yet been computed
            interval = set(pos.open_interval(C,orbit))
            if interval.issubset(computed):
                
                # Initialize the shift dictionary for the orbit at C to be C's fiber's cohomology
                restr_dict[orbit][C] = fibers[C]
                
                
                # Subtract off the terms occuring in other IC's according to their multiplicities
                restr_dict[orbit][C] = restr_dict[orbit][C] - sum([multiplicities[C2]*restr_dict[C2][C] for C2 in interval])
                
            
                # Use the fact that IC(C')|C is contained in degrees D, dim C < D <= dim C' for C < C'
                    # Also use the fact that the shifts will be contained in the interval [-defect,defect]
                    # Note we use Poincare-Verdier duality to obtain the symmetry in the following polynomial
                multiplicities[C] = _sage_const_0 *t
                for i in range(_sage_const_0 ,int(defect)+_sage_const_1 ):
                    if dim_dict[C]-i != _sage_const_0  and i != _sage_const_0 :
                        multiplicities[C] += restr_dict[orbit][C].coefficient(t**(dim_dict[C]-i))*(t**(-i)+t**i)
                    elif dim_dict[C]-i != _sage_const_0  and i == _sage_const_0 :
                        multiplicities[C] += restr_dict[orbit][C].coefficient(t**(dim_dict[C]-i))
                    elif dim_dict[C]-i == _sage_const_0  and i != _sage_const_0 :
                        multiplicities[C] += restr_dict[orbit][C].constant_coefficient()*(t**(-i)+t**i)
                    elif dim_dict[C]-i == _sage_const_0  and i == _sage_const_0 :
                        multiplicities[C] += restr_dict[orbit][C].constant_coefficient()
                        
                # Remove terms from current orbits
                restr_dict[orbit][C] = restr_dict[orbit][C] - multiplicities[C]*restr_dict[C][C]
                
                # Add C to the set of computed orbits
                computed.add(C)
            else:
                # If there is a larger orbit that hasn't been tested yet, set C to be computed
                # in the next iteration
                next_step.add(C)
                
        # Initialize the next list orbits to obtain lower covers for as the immediate previously computed orbits
        cover_list = iter_list.difference(next_step)
        
        
def semi_small(orbit, restr_dict, dim_dict, fibers, pos, t):
    """
    Computes the IC stalk shifts for the singular orbit inputted using
    the current semi-small resolution of singularities

    Parameters
    ----------
    orbit : rank triangle
        singular orbit to be resolved
    restr_dict : dict
        dictionary of IC stalk shifts already computed for other orbits in the Vogan
    dim_dict : dict
        dictionary of dimensions of orbits
    fibers : dict
        dictionary of fibers in the resolution for all orbits less than the current one
    pos : Poset
        Poset of orbits using the standard closure ordering
    """
    # Initialize dictionary of multiplicities, where all shifts are zero
    # since our resolution is semi-small
    multiplicities = dict([(C,_sage_const_0 *t) for C in fibers.keys()])
    
    # Initialize set of orbits with computed multiplicities
    computed = set()
    
    # Initialize list of orbits we will take the lower cover of
        # Note that this follows a process of "inverse induction" in the sense that
        # we find multiplicities for the largest orbits first then move down to their next level
    cover_list = {orbit}
    
    # Initialize the set of orbits to be skipped on a given iteration
    next_step = set()
   
    # Iterates until all orbits in the fibers dictionary are computed
    while computed != set(fibers.keys()):
        # Initializes list of orbits to compute multiplicities of in this iteration
        iter_list = next_step.union({C for C2 in cover_list 
                                     for C in pos.lower_covers(C2) if not C in computed})
        # Reset next step set to be empty
        next_step = set()
        for C in iter_list:
            # Initializes the interval of orbits bewtween the current one and our orbit of interest
            # to ensure there are no larger orbits which have not yet been computed
            interval = set(pos.open_interval(C,orbit))
            if interval.issubset(computed):
                
                # Initialize the shift dictionary for the orbit at C to be C's fiber's cohomology
                restr_dict[orbit][C] = fibers[C]
                
                # Subtract off the terms occuring in other IC's according to their multiplicities
                restr_dict[orbit][C] = restr_dict[orbit][C] - sum([multiplicities[C2]*restr_dict[C2][C] for C2 in interval])
                
                
                # If the dimension of C occurs as a shift in the cohomology of its fiber, then set 
                # its multiplicity to be the multiplicity of that shift
                if dim_dict[C] != _sage_const_0 :
                    multiplicities[C] = restr_dict[orbit][C].coefficient(t**(dim_dict[C]))
                else:
                    multiplicities[C] = restr_dict[orbit][C].constant_coefficient()
                
                # Remove terms from current orbits
                restr_dict[orbit][C] = restr_dict[orbit][C] - multiplicities[C]*restr_dict[C][C]
                    
                
                # Add C to the set of computed orbits
                computed.add(C)
            else:
                # If there is a larger orbit that hasn't been tested yet, set C to be computed
                # in the next iteration
                next_step.add(C)
                
        # Initialize the next list orbits to obtain lower covers for as the immediate previously computed orbits
        cover_list = iter_list.difference(next_step)
        
        
        
        
        
def product_cohom(cohom, list_of_cohom, t):
    """
    Computes the tensor product of a collection of cohomologies using recursion

    Parameters
    ----------
    cohom : dict
        a dictionary describing a cohomology as shifts with multiplicities
    list_of_cohom : list
        a list of size >= 1 of cohomology dictionaries
    """
    
    # If the list is of length greater than one, perform recursion by taking the product with the 
    # cohomology of the product of the list elements with themselves
    if len(list_of_cohom) > _sage_const_1 :
        return cohom*product_cohom(list_of_cohom[_sage_const_0 ], list_of_cohom[_sage_const_1 :], t)
    elif len(list_of_cohom) == _sage_const_1 : # Else, use distributivity to compute the product explicitly
        return cohom*list_of_cohom[_sage_const_0 ]
        
        
        
def grassman_cohom(grassman_pair, t, shift = _sage_const_0 ):
    """
    Computes the cohomology of a grassmannian (with a possible added shift)

    Parameters
    ----------
    grassman_pair : tuple
        A pair of integers corresponding to the subspace and total space dimension of the grassmannian
    shift : int
        An optional additional integer shift
    """
    
    # Initialize dictionary of number of occurences of each shift (before multiplication by -2)
    partition_dict = partitions(int(grassman_pair[_sage_const_0 ]),int(grassman_pair[_sage_const_1 ]))
    
    # Computes the cohomology dictinary using -2 times the original shift, plus the optional shift, along 
    # with the occurences found in the partition.
    cohom_pol = _sage_const_0 
    for i in partition_dict.keys():
        cohom_pol += partition_dict[i]*t**(-_sage_const_2 *i + shift)
    
    # Returns the cohomology dictionary
    return cohom_pol
    
    
    
    
def partitions(k,n):
    """
    Computes a dictionary containing the number of partitions of an integer i into k nonnegative
    integers between 0 and n-k, for each integer between 0 and k(n-k)
    
    Parameters
    ----------
    k : int
        the number of components in the partition
    n : int
        An integer >= k
    """
    # Initialize the partition dictionary with zeros
    partition_dict = dict([(i,_sage_const_0 ) for i in range(_sage_const_0 ,int(k*(n-k))+_sage_const_1 )])
    
    # Using compinations_with_replacement, count the number of occurences of each sum
    for tup in cwr(range(_sage_const_0 ,n-k+_sage_const_1 ), k):
        partition_dict[sum(tup)] += _sage_const_1 
    
    # Return the partition dictionary
    return partition_dict
    
    
    
def fiber(res_orbit, sub_orbit, dim_dict, t):
    """
    Computes the fiber of an element in sub_orbit in the resolution of res_orbit
        
        This method is incomplete and only works for rank triangles of a particular form
    """
    
    # Initialize number of eigenspaces
    length = res_orbit.get_length()
    
    # Initialize list for storing fibers
    fiber_list = []
    
    # Get the arrays associated with the orbits' rank triangles
    res_array = res_orbit.get_array()
    sub_array = sub_orbit.get_array()
    
    # Obtain the array 
    diag = np.diag(res_array, k = _sage_const_0 )[_sage_const_1 :]
    # Obtains a list of all diagonals
    res_diags = [np.diag(res_array, k = -l) for l in range(_sage_const_1 ,length)]
    sub_diags = [np.diag(sub_array, k = -l) for l in range(_sage_const_1 ,length)]
    
    # Explained in the compactifications and resolutions overleaf document
    if length == _sage_const_2 : 
        dimension = _sage_const_0 
        fiber_list.append(grassman_cohom((res_diags[_sage_const_0 ][_sage_const_0 ]-sub_diags[_sage_const_0 ][_sage_const_0 ], diag[_sage_const_0 ]- sub_diags[_sage_const_0 ]), 
                                         t, shift=dim_dict[res_orbit]))
        dimension += (res_diags[_sage_const_0 ][_sage_const_0 ]-sub_diags[_sage_const_0 ][_sage_const_0 ])*(diag[_sage_const_0 ]-res_diags[_sage_const_0 ][_sage_const_0 ])
        
    elif length == _sage_const_3  and diag[-_sage_const_1 ] == _sage_const_1 :
        
        dimension = _sage_const_0 
        for i in range(len(res_diags[_sage_const_0 ])):
            if res_diags[-_sage_const_1 ][_sage_const_0 ] == _sage_const_0  and i == _sage_const_0 :
                fiber_list.append(grassman_cohom((res_diags[_sage_const_0 ][i]-sub_diags[_sage_const_0 ][i],
                                                  diag[i]-sub_diags[_sage_const_0 ][i]-sub_diags[_sage_const_0 ][i+_sage_const_1 ]), t, shift = dim_dict[res_orbit]))
                dimension += (res_diags[_sage_const_0 ][i]-sub_diags[_sage_const_0 ][i])*(diag[i]-res_diags[_sage_const_0 ][i]-sub_diags[_sage_const_0 ][i+_sage_const_1 ])
            elif res_diags[_sage_const_0 ][i]-sub_diags[_sage_const_0 ][i] != _sage_const_0  and res_diags[_sage_const_0 ][i]-sub_diags[_sage_const_0 ][i] != diag[i]-sub_diags[_sage_const_0 ][i]:
                fiber_list.append(grassman_cohom((res_diags[_sage_const_0 ][i]-sub_diags[_sage_const_0 ][i],
                                                  diag[i]-sub_diags[_sage_const_0 ][i]), t, shift = dim_dict[res_orbit]))
                dimension += (res_diags[_sage_const_0 ][i]-sub_diags[_sage_const_0 ][i])*(diag[i]-res_diags[_sage_const_0 ][i])
    elif length > _sage_const_3  or diag[-_sage_const_1 ] > _sage_const_1 :
        return [], -_sage_const_1 
    
    if len(fiber_list) == _sage_const_1 :
        fiber = fiber_list[_sage_const_0 ]
    elif len(fiber_list) > _sage_const_1 :
        fiber = product_cohom(fiber_list[_sage_const_0 ],fiber_list[_sage_const_1 :], t)
    elif len(fiber_list) == _sage_const_0 :
        fiber = t**(dim_dict[res_orbit])
    
    return fiber, dimension
    
    
    


#################################################### Main Functions ####################################################


def geomMatrix(infParam, t):
    """
    This function computes the geometric multiplicity matrix associated
    with the inputted unramified infinitesimal parameter.
    
    Parameters
    ----------
    infParam :
        A multiset of twists associated with an infinitesimal parameter
     
    Example input: 
        [1, 0, 0, 0, -1]
    """
    
    # Computes the multisegments for the infinitesimal parameter
    supp = Multisegment([(i,i) for i in infParam])
    supp.compute_less_thans()
    
    # Computes the rank triangles associated with the multisegments
    rankTriags = {Rank_Triangle(multi) for multi in supp.get_less_thans().keys()}
    
    # Computes the poset for the rank triangles using the closure ordering
    pos = Poset(data = (rankTriags, order))
    
    # Computes the vogan and unique closed orbit
    Vlambda = pos.top()
    C0 = pos.bottom()
    
    # Initialize a dictionary of orbits as keys and restriction dictionaries as values
    restr_dict = dict([(C,dict([(C2,_sage_const_0 *t) for C2 in rankTriags])) for C in rankTriags])
    
    # Initialize a dictionary of orbit dimensions
    dim_dict = dict([(C,dim_orbit(C.get_array())) for C in rankTriags])
    
    # Initialize a set of computed orbits
    computed = set()
    
    # Initialize a set of smooth orbits and determine which orbits are smooth
    smooth_orbs = set()
    for C in rankTriags:
        if isSmooth(C, dim_dict[C], dim_dict[Vlambda]):
            smooth_orbs.add(C)
            
    # Initialize the set of non-smooth-orbits
    non_smooth_orbs = {C for C in rankTriags if not C in smooth_orbs}
    
    # Use the fact that for smooth Cbar, IC(C,1_C) = 1_{Cbar}[dim C]
    for C in smooth_orbs:
        for C2 in rankTriags:
            if C2 <= C:
                restr_dict[C][C2] += t**(dim_dict[C])
        
        if not C in computed:
            computed.add(C)
                
    # Initialize list of orbits we will take the upper cover of
        # Note that this follows a process of "induction" in the sense that
        # we find shift dictionaries for stalks for the smallest orbits first then move up to their next level
    cover_list = {C0}
    
    # Initialize the set of orbits to be skipped on a given iteration
    next_step = set()
    
    # Iterates until all orbits' stalks are computed
    while computed != rankTriags:
        # Initializes list of orbits to compute stalks of in this iteration
        iter_list = next_step.union({C for C2 in cover_list 
                                     for C in pos.upper_covers(C2)})
        # Reset next step set to be empty
        next_step = set()
        for C in iter_list:
            if not C in computed:
                # Check if the interval of orbits between the current one and our orbit of interest
                # contains no smaller orbits which have not yet been computed
                if set(pos.open_interval(C0,C)).issubset(computed):
                    # Computes the stalk using a resolution of singularities
                    check = resolve(C, rankTriags, restr_dict, dim_dict, pos, t)
                    if check == -_sage_const_1 :
                        return -_sage_const_1 , -_sage_const_1 , -_sage_const_1 
                    # Adds the orbit to the computed set
                    computed.add(C)
                else:
                    # If there is a smaller orbit that hasn't been tested yet, set C to be computed
                    # in the next iteration
                    next_step.add(C)
        
        # Initialize the next list orbits to obtain upper covers for as the immediate previously computed orbits
        cover_list = iter_list.difference(next_step)
    
    # Returns the stalk dictionary, the order poset, and the rank triangles set
    return restr_dict, rankTriags, dim_dict
    
    
    
def prodGeomMatrix(infParamList, t):
    """"
    This function computes the geometric matrix for a product of Vogan varities given
    by a list of infinitesimal parameters
    
    Parameters
    ----------
    infParamList : list
        A list of infinitesimal parameters given by lists of exponents
    """
    
    # Compute the geometric matrix for each infinitesimal parameter
    voganTriples = [geomMatrix(infParam, t) for infParam in infParamList]
    
    # Take the cartesian product of the lists of orbits in each Vogan to obtain
    # the orbits in the product Vogan
    rankTriags = [triple[_sage_const_1 ] for triple in voganTriples]
    rankTriags = list(cart_prod(*rankTriags))
    
    # Define the dimension dictionary of the orbits in the product using the sum of dimensions 
    # of the component orbits
    dim_dict = dict([(C,sum([voganTriples[i][_sage_const_2 ][C[i]] for i in range(len(voganTriples))])) for C in rankTriags])
    
    # Initialize a nested dictionary for storing stalks as polynomials
    restr_dict = dict([(C,dict([(C2, _sage_const_0 *t) for C2 in rankTriags])) for C in rankTriags])
    
    # Take the product of the stalk polynomials of the component orbits for each orbit in the product Vogan
    for C in rankTriags:
        for C2 in rankTriags:
            restr_dict[C][C2] = prod([voganTriples[i][_sage_const_0 ][C[i]][C2[i]] for i in range(len(voganTriples))])
    
    return restr_dict, rankTriags, dim_dict
    
    
def display_GeomMatrix(infParam, print_orbs = False, polynomials = False):
    """
    This function displays the geometric multiplicity matrix associated 
    with the given infinitesimal parameter
    
    Parameters
    ----------
    infParam : list
        A multiset of exponents associated with an infinitesimal parameter
     
    Example input: 
        [1, 0, 0, 0, -1]
    """
    
    # Initialize polynomial ring
    t = var('t')
    L = LaurentPolynomialRing(QQ, _sage_const_1 , names=('t',)); (t,) = L._first_ngens(1)
    
    # Computes the geometric multiplicity matrix
    if len(infParam) == _sage_const_1 :
        restr_dict, rankTriags, dim_dict = geomMatrix(infParam[_sage_const_0 ], t)
    else:
        restr_dict, rankTriags, dim_dict = prodGeomMatrix(infParam, t)
    
    if restr_dict == -_sage_const_1 :
        print("No algorithm yet")
        return
    
    # Initialize the array and the number of columns it has
    latex_str = r"$\begin{array}{c|" + len(rankTriags)*"c" + "}"
    latex_str += r"m_{geo}^{\lambda} & "
    latex_str_backup = latex_str
    # Sorts the rank triangles so the resulting array is lower triangular
    rankTriagsSorted = sorted(rankTriags, key = lambda X:dim_dict[X])
    
    # Sets the first row as restrictions to each orbit
    for i in range(len(rankTriagsSorted)):
        latex_str += r"\vert_{" + repr(rankTriagsSorted[i]) + "}"
        
        if i < len(rankTriagsSorted)-_sage_const_1 :
            latex_str += r" & "
        else:
            latex_str += r" \\ \hline "
    
    # Sets all following rows as IC's follows by sums of shifts of local systems, with associated multiplicities
    for i in range(len(rankTriagsSorted)):
        latex_str += r"IC(" + repr(rankTriagsSorted[i]) + r", \mathbb{1}_{" + repr(rankTriagsSorted[i]) + r"}) & "
        IC_dict = restr_dict[rankTriagsSorted[i]]
        for j in range(len(rankTriagsSorted)):
            shift_dict = IC_dict[rankTriagsSorted[j]].dict()
            
            if polynomials:
                # Translates the polynomial into the appropriate Kazhdan-Lusztig polynomial
                inter_pol = IC_dict[rankTriagsSorted[j]]*t**(-dim_dict[rankTriagsSorted[i]])
                intermediate = inter_pol.constant_coefficient()
                for k in range(_sage_const_2 ,int(dim_dict[rankTriagsSorted[i]]+_sage_const_1 ),_sage_const_2 ):
                    intermediate += t**(int(k//_sage_const_2 ))*inter_pol.coefficient(t**(-k))
                latex_str += str(intermediate)#  str(IC_dict[rankTriagsSorted[j]])
            else:
                if len(shift_dict.keys()) > _sage_const_0 :
                    for k in range(len(shift_dict.keys())):
                        shift = list(shift_dict.keys())[k]
                        multiplicity = int(shift_dict[shift])
                        if multiplicity > _sage_const_1 :
                            latex_str += str(multiplicity) + r"\mathbb{1}_{" + repr(rankTriagsSorted[j]) + r"}[" + str(shift[_sage_const_0 ]) + r"]"
                        elif multiplicity == _sage_const_1 :
                            latex_str += r"\mathbb{1}_{" + repr(rankTriagsSorted[j]) + r"}[" + str(shift[_sage_const_0 ]) + r"]"
                        elif k > _sage_const_1 :
                            latex_str = latex_str_backup
                        latex_str_backup = latex_str
                        if k < len(shift_dict.keys()) - _sage_const_1 :
                            latex_str += r" \oplus "
                else:
                    latex_str += "0"
            
            if j < len(rankTriagsSorted) - _sage_const_1 :
                latex_str += r" & "
        
        latex_str += r" \\ "
    
    latex_str += r"\end{array}$"
    
    display(Markdown(latex_str))
    
    if print_orbs:
        display_orbits(rankTriagsSorted)
        
        
        
def display_orbits(rankTriagsSorted):
    """
    Displays a latex formatted description of all orbits in the given sorted list.
    If an orbit is given as a product of (presumed) non-linked Vogans then the 
    corresponding rank triangle is constructed with the rank triangles of the 
    component orbits as sub-triangles.
    
    Parameters:
    -----------
    rankTriagsSorted : list
        a sorted list of rank triangle objects, or tuples of rank triangle objects
    """
    for C in rankTriagsSorted:
        print(repr(C) + ": ")
        if type(C) is tuple:
            # Adjoin the rank triangles by creating the union of the multisegments
            # attached to each rank triangle, and then converting the result to a rank triangle
            multis = [multi_segment(orbit.get_array(), orbit.get_inf()[_sage_const_0 ]) for orbit in C]
            multi = multis[_sage_const_0 ]
            for multiseg in multis[_sage_const_1 :]:
                multi = multi + multiseg
            Orbit, eigen = rank_triag(multi)
            display(Markdown(triag_str_to_latex(array_to_triag(Orbit, eigen), eigen)))
        else:
            rank_array = C.get_array()
            eigen_list = C.get_inf()
            display(Markdown(triag_str_to_latex(array_to_triag(rank_array, eigen_list), eigen_list)))
            
        print("")
        
        
        
def display_SpecMatrix(infParam, print_multis = False):
    """
    This function displays the spectral multiplicity matrix associated 
    with the given infinitesimal parameter using geometric techniques
    
    Parameters
    ----------
    infParam :
        A multiset of twists associated with an infinitesimal parameter
     
    Example input: 
        [-1, 0, 0, 0, 1]
    """
    
    # Initialize polynomial ring
    t = var('t')
    L = LaurentPolynomialRing(QQ, _sage_const_1 , names=('t',)); (t,) = L._first_ngens(1)
    
    # Computes the geometric multiplicity matrix
    if len(infParam) == _sage_const_1 :
        restr_dict, rankTriags, dim_dict = geomMatrix(infParam[_sage_const_0 ], t)
    else:
        restr_dict, rankTriags, dim_dict = prodGeomMatrix(infParam, t)
    
    if restr_dict == -_sage_const_1 :
        print("No algorithm yet")
        return
    
    # Initialize the array and the number of columns it has
    latex_str = r"$\begin{array}{c|" + len(rankTriags)*"c" + "}"
    latex_str += r"m_{spec}^{\lambda} & "
    latex_str_backup = latex_str
    # Sorts the rank triangles so the resulting array is lower triangular
    rankTriagsSorted = sorted(rankTriags, key = lambda X:dim_dict[X])
    
    # Sets the first row as restrictions to each orbit
    for i in range(len(rankTriagsSorted)):
        latex_str += r"Q(a_{" + repr(rankTriagsSorted[i]) + "})"
        
        if i < len(rankTriagsSorted)-_sage_const_1 :
            latex_str += r" & "
        else:
            latex_str += r" \\ \hline "
    
    # Sets all following rows as IC's follows by sums of shifts of local systems, with associated multiplicities
    for i in range(len(rankTriagsSorted)):
        latex_str += r"M_Q(a_{" + repr(rankTriagsSorted[i]) + r"}) & "
        
        for j in range(len(rankTriagsSorted)):
            shift_pol = restr_dict[rankTriagsSorted[j]][rankTriagsSorted[i]]
            
            latex_str += " "+str(int(shift_pol.subs(t=_sage_const_1 )))
            
            if j < len(rankTriagsSorted) - _sage_const_1 :
                latex_str += r" & "
        
        latex_str += r" \\ "
    
    latex_str += r"\end{array}$"
    
    display(Markdown(latex_str))
    
    if print_multis:
        display_Standards(rankTriagsSorted)
        
        
        
def display_Standards(rankTriagsSorted):
    """
    Displays a latex formatted description of all multisegments in the given sorted list.
    
    Parameters:
    -----------
    rankTriagsSorted : list
        a sorted list of rank triangle objects, or tuples of rank triangle objects
    """
    for C in rankTriagsSorted:
        if type(C) is tuple:
            # Adjoin the multisegments of the component orbits in the product
            multis = [multi_segment(orbit.get_array(), orbit.get_inf()[_sage_const_0 ]) for orbit in C]
            multi = multis[_sage_const_0 ]
            for multiseg in multis[_sage_const_1 :]:
                multi = multi + multiseg
            
            display(Markdown(r"$M_Q(a_{" + repr(C) + r"})$:"))
            standard_String(multi)
        else:
            multi = multi_segment(C.get_array(), C.get_inf()[_sage_const_0 ])
        
            display(Markdown(r"$M_Q(a_{" + repr(C) + r"})$:"))
            standard_String(multi)
        
        print('')
        
        
        
#################################################### Widgets ####################################################


def geom_matr(infParam, print_orbs = False, polynomials = False):
    """
    Computes and displays the geometric multiplicity matrix for an infinitesimal parameter
    given as a string of a specified form.
    
    Parameters:
    -----------
    infParam : str
        string describing a product of non-linked infinitesimal parameter runs
    print_orbs : bool
        boolean codifying if the orbits should be printed
    polynomials : bool
        boolean codifying if the restrictions should be represented by Kazhdan-Lusztig polynomials
    """
    
    # Separates the segments in the larger infinitesimal parameter and turns them into a list of lists of floats
    infParamStr = infParam.replace(" ","").split(":")
    infParam = [[float(i) for i in re.findall(r'[-+]?\d+\.?\d*', subinfParam)] for subinfParam in infParamStr]
    
    # Check that all segments in the larger infinitesimal parameter are not linked and are not missing terms
    for i in range(len(infParam)):
        param = set(infParam[i])
        if not set([i/_sage_const_2p0  for i in range(int(_sage_const_2 *min(param)),int(_sage_const_2 *max(param))+_sage_const_1 , _sage_const_2 )]).issubset(param):
            print("Infinitesimal parameter segments must not have any gaps")
            return
        for j in range(i+_sage_const_1 ,len(infParam)):
            param = param.union(set([min(param)-_sage_const_1 ,max(param)+_sage_const_1 ]))
            if param.intersection(set(infParam[j])) != set():
                print("Infinitesimal parameter segments must not be linked")
                return
    
    # Display the geometric matrix
    display_GeomMatrix(infParam, print_orbs = print_orbs, polynomials = polynomials)
    
    
    
def spec_matr(infParam, print_multis = False):
    """
    Computes and displays the spectral multiplicity matrix for an infinitesimal parameter
    given as a string of a specified form.
    
    Parameters:
    -----------
    infParam : str
        string describing a product of non-linked infinitesimal parameter runs
    print_multis : bool
        boolean codifying if the standard representations should be printed
    """
    
    # Separates the segments in the larger infinitesimal parameter and turns them into a list of lists of floats
    infParamStr = infParam.replace(" ","").split(":")
    infParam = [[float(i) for i in re.findall(r'[-+]?\d+\.?\d*', subinfParam)] for subinfParam in infParamStr]
    
    # Check that all segments in the larger infinitesimal parameter are not linked and are not missing terms
    for i in range(len(infParam)):
        param = set(infParam[i])
        if not set([i/_sage_const_2p0  for i in range(int(_sage_const_2 *min(param)),int(_sage_const_2 *max(param))+_sage_const_1 , _sage_const_2 )]).issubset(param):
            print("Infinitesimal parameter segments must not have any gaps")
            return
        for j in range(i+_sage_const_1 ,len(infParam)):
            param = param.union(set([min(param)-_sage_const_1 ,max(param)+_sage_const_1 ]))
            if param.intersection(set(infParam[j])) != set():
                print("Infinitesimal parameter segments must not be linked")
                return
    
    # Display the spectral matrix
    display_SpecMatrix(infParam, print_multis = print_multis)
    
    
    
def geom_matr_widget():
    """
    Creates an interactive widget for display_GeomMatrix
    """
    im = widgets.interact_manual(geom_matr, 
                     infParam = widgets.Textarea(value="[-1,0,1]", description = "Infinitesimal Powers"),
                    print_orbs = widgets.Checkbox(value=False, description='Orbits',disabled=False, indent=True),
                    polynomials = widgets.Checkbox(value=False, description='Polynomials',disabled=False, indent=True))
    im.widget.children[_sage_const_3 ].description = "Run Algorithm"
    im.widget.children[_sage_const_3 ].style.button_color = 'violet'
    
    
def spec_matr_widget():
    """
    Creates an interactive widget for display_SpecMatrix
    """
    im = widgets.interact_manual(spec_matr, 
                     infParam = widgets.Textarea(value="[-1,0,1]", description = "Infinitesimal Powers"),
                    print_multis = widgets.Checkbox(value=False, description='Standards',disabled=False, indent=True))
    im.widget.children[_sage_const_2 ].description = "Run Algorithm"
    im.widget.children[_sage_const_2 ].style.button_color = 'violet'
    
    
    

