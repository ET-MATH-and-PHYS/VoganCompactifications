

# This file was *autogenerated* from the file Rep_Sage_lib.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_100 = Integer(100); _sage_const_12 = Integer(12); _sage_const_500 = Integer(500); _sage_const_2 = Integer(2); _sage_const_5 = Integer(5); _sage_const_3 = Integer(3)# Imports
import numpy as np
import re
from IPython.display import display, Markdown, Latex
import ipywidgets as widgets

class Segment:
    """
    A class used to symbolically represent a segment of cuspidal representations

    ...

    Attributes
    ----------
    seg_lower : float
        an integer (or half integer) describing the lower bound of the segment
    seg_upper : float
        an integer (or half integer) describing the upper bound of the segment
    seg_empty : bool
        a boolean specifying if the segment is empty or not

    Methods
    -------
    is_empty()
        Returns if the segment is empty or not
    get_segment_lower()
        Returns the lower value of the segment
    get_segment_upper()
        Returns the upper value of the segment
    get_length()
        Returns the length of the segment
    contains_seg(input_seg)
        Returns if the inputted segment is contained inside the current segment.
    contains(value)
        Returns if the inputted value is contained inside the current segment.
    linked(input_seg)
        Returns if the inputted segment is linked with the current segment.
    precedes(input_seg)
        Returns if the inputted segment is linked with the current segment.
    subtract()
        Reduces the upper bound of the segment by 1. If the upper bound
        goes below the lower bound, set the segment as empty.
    intersect(other)
        Returns a new segment which is the intersection of 
        the current segment and the inputted segment
    union(other)
        Returns a new segment which is the union of 
        the current segment and the inputted segment
    string_format()
        Defines a string representing the segment as a segment of representations with base cuspidal representation rho
        and character nu.
    """
    
    def __init__(self, i, j, empty = False):
        """
        Initializes the segment and its upper and lower bounds
        
        Parameters
        ----------
        i : float
            an integer (or half integer) for the lower bound of the segment
        j : float
            an integer (or half integer) for the upper bound of the segment
        empty : bool, optional
            a boolean to specify if the segment is empty or not

        Raises
        ------
        ValueError
            If the lower bound, i, is greater than the upper bound, j
        """
        
        # If i <= j storing i and j as upper and lower bounds
        if i <= j and float(j-i).is_integer():
            self.seg_lower = i
            self.seg_upper = j
            self.empty = empty
        else: # Else raise value error
            raise ValueError("The first argument must be less than the second")
    
    def __eq__(self, other):
        """
        Defines when two segments are equal
        
        Parameters
        ----------
        other : segment
            the segment being compared with

        Raises
        ------
        NotImplemented
            If the input, other, is not a segment
        """
        
        # Two segments are equal if they have the same upper and lower bound
        if other.get_segment_lower() == self.seg_lower and other.get_segment_upper() == self.seg_upper:
            return True
        else:
            return False
    
    
    def __ne__(self, other):
        """
        Defines when two segments are not equal
        
        Parameters
        ----------
        other : segment
            the segment being compared with

        Raises
        ------
        NotImplemented
            If the input, other, is not a segment
        """
        
        return not self.__eq__(other)
    
    def __lt__(self, other):
        """
        Defines when a segment is less than another
        
        Parameters
        ----------
        other : segment
            the segment being compared with
        """
        return (self.seg_lower,self.seg_upper) < (other.get_segment_lower(),other.get_segment_upper()) 
    
    def __hash__(self):
        """
        Defines the hash for a segment using the hash of a tuple
        """
        return hash((self.seg_lower, self.seg_upper))
    
    
    def is_empty(self):
        """
        Returns if the segment is empty or not
        """
        return self.empty
    
    def get_segment_lower(self):
        """
        Returns the lower value of the segment
        """
        return self.seg_lower
    
    def get_segment_upper(self):
        """
        Returns the upper value of the segment
        """
        return self.seg_upper
    
    def get_length(self):
        """
        Returns the length of the segment
        """
        return self.seg_upper - self.seg_lower + 1
    
    def contains_seg(self, input_seg):
        """
        Returns if the inputted segment is contained inside the current segment.
        
        Parameters
        ----------
        input_seg : segment
            the segment being compared with
        """
        
        # Initialize the upper and lower bounds of the input segment
        input_low = input_seg.get_segment_lower()
        input_high = input_seg.get_segment_upper()
        
        # If the lower bound of the inputted segment is greater than the lower bound
        # of the current segment and the upper bound of the inputted segment is less than
        # the upper bound of the current segment
        if self.seg_lower <= input_low and self.seg_upper >= input_high:
            return True
        else:
            return False
        
    def contains(self, value):
        """
        Returns if the inputted value is contained inside the current segment.
        
        Parameters
        ----------
        value : float
            the value being checked
        """
        # Checks if the value is of the same type as the bounds of the segment, and is contained within them
        if value >= self.seg_lower and value <= self.seg_lower and (value-self.seg_lower == floor(value-self.seg_lower)):
            return True
        else:
            return False
    
    def linked(self, input_seg):
        """
        Returns if the inputted segment is linked with the current segment.
        
        Parameters
        ----------
        input_seg : segment
            the segment being compared with
        """
        
        # Initialize the upper and lower bounds of the input segment
        input_low = input_seg.get_segment_lower()
        input_high = input_seg.get_segment_upper()
        
        # The segments are linked iff one precedes the other
        if self.precedes(input_seg) or input_seg.precedes(self):
            return True
        else:
            return False
        
    def precedes(self, input_seg):
        """
        Returns if the inputted segment is linked with the current segment.
        
        Parameters
        ----------
        input_seg : segment
            the segment being compared with
        """
        
        # Initialize the upper and lower bounds of the input segment
        input_low = input_seg.get_segment_lower()
        input_high = input_seg.get_segment_upper()
        
        # The current segment precedes the input if its lower bound is less than the input's, its upper bound is 
        # at most one less than the input's lower bound and less than the input's upper bound.
        if input_low > self.seg_lower and input_low <= self.seg_upper+_sage_const_1  and input_high > self.seg_upper:
            return True
        else:
            return False
    
    def subtract(self):
        """
        Reduces the upper bound of the segment by 1. If the upper bound
        goes below the lower bound, set the segment as empty.
        """
        lower = self.seg_lower
        upper = self.seg_upper
        # If the segment is not empty reduce its upper bound and check 
        # if the upper bound is now less than than the lower bound
        if not self.empty:
            lower = self.seg_lower
            upper = self.seg_upper - _sage_const_1 
            if upper < lower:
                return Segment(_sage_const_0 , _sage_const_0 , empty = True)
            else:
                return Segment(lower, upper)
        else:
            return Segment(_sage_const_0 , _sage_const_0 , empty = True)
    
    
    def intersect(self, other):
        """
        Returns a new segment which is the intersection of 
        the current segment and the inputted segment
        
        Parameters
        ----------
        other : segment
            the segment being intersected with
        """
        
        # Sets the lower bound of the new segment to be the max of the two lower bounds of the inputted segments
        lower = max(self.seg_lower, other.get_segment_lower())
        
        # Sets the upper bound of the new segment to be the min of the two upper bounds of the inputted segments
        upper = min(self.seg_upper, other.get_segment_upper())
        
        # If lower > upper return the empty segment
        if lower > upper:
            return Segment(_sage_const_0 , _sage_const_0 , empty = True)
        else: # Else return the segment with lower and upper as the bounds
            return Segment(lower, upper)
    
    def union(self, other):
        """
        Returns a new segment which is the union of 
        the current segment and the inputted segment
        
        Parameters
        ----------
        other : segment
            the segment being unioned with
        """
        
        # Sets the lower bound of the new segment to be the min of the two lower bounds of the inputted segments
        lower = min(self.seg_lower, other.get_segment_lower())
        
        # Sets the upper bound of the new segment to be the max of the two upper bounds of the inputted segments
        upper = max(self.seg_upper, other.get_segment_upper())
        
        # Returned the unioned segment
        return Segment(lower, upper)
    
    def __repr__(self):
        """
        Represent a segment as an interval with lower and upper bounds
        """
        if self.seg_lower != self.seg_upper:
            return f"[{self.seg_lower}, {self.seg_upper}]"
        else:
            return f"[{self.seg_lower}]"
    
    def string_format(self):
        """
        Defines a string representing the segment as a segment of representations with base cuspidal representation rho
        and character nu.
        """
        # Use Sage Latex expressions to define string
        si = f"{self.seg_lower}"
        sj = f"{self.seg_upper}"
        s="[" + LatexExpr(r"\nu^{" + si + r"}\rho") + "," + LatexExpr(r"\nu^{" + sj + r"}\rho") + "]"
        return s
    
    def __str__(self):
        """
        Shows the string representation of the segment when asked to print it
        """
        show(self.string_format())
        return ""
        
        
class Multisegment:
    """
    A class used to symbolically represent a multisegment of cuspidal representations

    ...

    Attributes
    ----------
    multi : dict
        a dictionary for storing the segments in our multisegments and their multiplicity
    ordering : list
        a list for storing the ordering of our segments
    less_thans_computed : bool
        a boolean specifying if the less_thans list has been computed for this multisegment
    less_thans : list
        a list of all multisegments less than the current multisegment
    rel : list
        a list of pairs of multisegments in less_thans describing the order relation between them

    Methods
    -------
    get_support()
        Returns the support of the multisegment as a multiset
    get_max()
        Returns the maximum multisegment associated with the current support
    get_max_int()
        Returns the highest segment upper bound in the multisegment
    get_min_int()
        Returns the lowest segment lower bound in the multisegment
    get_shift()
        Returns a multisegment of the same shape shifted by a specified amount
    subtract()
        Reduces the upper bound of each segment by 1
    clean_dict()
        Removes any empty segments in the dictionary
    clean_ordering()
        Removes any empty segments in the ordering list
    get_ordering()
        Returns a copy of the ordering list
    get_dict()
        Returns a copy of the segment dictionary
    get_less_thans()
        Returns a copy of the list of multisegments less than the current one
    get_least()
        Returns the smallest multisegment less than the current one
    get_map()
        Return the map associated with the multisegment
    get_rel()
        Returns the multisegments less than relation list
    get_dual()
        Returns the dual of the multisegment using the Moeglin-Waldspurger algorithm
    elem_opp()
        Performs an elementary operation on your multisegment for two given linked segments inside it
    least()
        Returns True if the multisegment has no linked segments, and hence has no multisegments less than it
    compute_less_thans()
        Computes the list of multisegments less than the current one
    recurse()
        A helper function for compute_less_thans()
    is_computed()
        Checks if compute_less_thans() has been run
    greater_than()
        Returns if the inputted multisegment is less than the current multisegment
    plot_poset()
        Plots the poset tree of multisegments less than or equal to the current one
    print_poset()
        Prints the multisegments less than or equal to the current one
    string_format()
        Defines a string representing the multisegment
    """
    def __init__(self, index_array, segs = False):
        """
        Initializes the multisegment and its segment components
        
        Parameters
        ----------
        index_array : list
            a list of index tuples for specifying segments (if segs = False), or a list
            of segments
        segs : bool, optional
            a boolean to specify if the inputted input array is an array of segments
        """
        
        # Initializes a dictionary for storing segments
        self.multi = {}
        # Initializes a list for storing the ordering of segments
        self.ordering = []
        
        if segs: 
            # If a segment list was giving set the ordering as equal to it
            self.ordering = index_array
            
            # For each segment in the index array, add it to the multi dictionary along with its multiplicity
            for seg in index_array:
                if seg in self.multi.keys():
                    self.multi[seg] += _sage_const_1 
                else:
                    self.multi[seg] = _sage_const_1 
        else:
            # For each pair of indices in the index array
            for pair in index_array:
                # Create a segment with lower and upper bounds specified by pair
                seg = Segment(pair[_sage_const_0 ], pair[_sage_const_1 ])
                
                # Either add the segment to the multi dictionary or increment its multiplicity
                if seg in self.multi.keys():
                    self.multi[seg] += _sage_const_1 
                else:
                    self.multi[seg] = _sage_const_1 
                # Append the segment to the ordering list
                self.ordering.append(seg)
            
        # Initializes the less_thans_computed flag to False
        self.less_thans_computed = False
        # Initializes dicitonary for storing multisegments less than the current one
        self.less_thans = {}
        
        # Initializes a list for storing the order relations between multisegments in less_thans
        self.rel = []
        
    
    def __hash__(self):
        """
        Defines the hash for a multisegment using the hash of its segments
        """
        return hash(tuple(sorted(self.ordering)))
    
    def __eq__(self, other):
        """
        Defines when two multisegments are equal
        
        Parameters
        ----------
        other : multisegment
            the multisegment being compared with
        """
        # If the two multisegments have the same dictionary then they are equal
        if other.get_dict() == self.get_dict():
            return True
        else:
            return False
    
    
    def __ne__(self, other):
        """
        Defines when two multisegments are not equal
        
        Parameters
        ----------
        other : segment
            the segment being compared with
        """
        
        return not self.__eq__(other)
    
    def __add__(self, other):
        """
        Defines the addition of two multisegments by concatenating their 
        ordering arrays
        
        Parameters
        ----------
        other : segment
            the segment being compared with
        """
        
        return Multisegment(self.get_ordering()+other.get_ordering(), segs = True)
    
    def __lt__(self, other):
        """
        Defines when a multisegment is less than another
        
        Parameters
        ----------
        other : segment
            the segment being compared with
        """
        
        return other.greater_than(self)
    
    def get_support(self):
        """
        Returns the support of the multisegment
        """
        
        # Initialize dictionary for the support
        support = {}
        
        # Adds the multiplicity of each term in each segment to the support
        for seg, multiplicity in self.multi.items():
            for j in range(int(2*seg.get_segment_lower()),int(2*seg.get_segment_upper()+_sage_const_1), 2):
                if j/2 in support.keys():
                    support[j/2] += multiplicity
                else:
                    support[j/2] = multiplicity
        
        return support
                
    def get_max(self):
        """
        Returns the maximum multisegment associated with the current multisegment
        """
        # Get the support of the current multisegment
        support = self.get_support()
        
        # Creates a list of basic segments associated with the support of our segment
        input_list = [Segment(j,j) for (j,num) in support.items() for i in range(num)]
        
        # Returns the maximum multisegment
        return Multisegment(input_list, segs = True)
                
    def get_max_int(self):
        """
        Returns the highest index in the segments of the multisegment
        """
        
        max_list = [seg.get_segment_upper() for seg in self.multi.keys()]
        
        return max(max_list)
    
    def get_min_int(self):
        """
        Returns the lowest index in the segments of the multisegment
        """
        
        min_list = [seg.get_segment_lower() for seg in self.multi.keys()]
        
        return min(min_list)
    
    def get_shift(self, shift):
        """
        Returns a shifted multisegment
        """
        
        # Creates a list of basic segments associated with the support of our segment
        input_list = [Segment(seg.get_segment_lower()+shift,seg.get_segment_upper()+shift)
                      for (seg,num) in self.multi.items() for i in range(num)]
        
        # Returns the maximum multisegment
        return Multisegment(input_list, segs = True)
    
    
    def subtract(self):
        """
        Reduces the upper bound of each segment in the multisegment by 1. If the upper bound
        goes below the lower bound for any segment, set the segment as empty.
        """
        
        # Initialize transfer dictionary
        transfer_dict = {}
        for key in multi.keys():
            # Replace each segment by its subtraction
            transfer_dict[key.subtract()] = self.multi[key]
        
        # Replace the current dictionary with the transfer dictionary
        self.multi = transfer_dict
        
        # Replace current ordering with the subtracted segment ordering
        self.ordering = [seg.subtract() for seg in self.ordering]
        
        # Cleans the multiset and ordering of empty segments
        self.clean_dict()
        self.clean_ordering()
    
    def clean_dict(self):
        """
        Cleans the multisegment by removing any empty segments
        """
        
        # Initialize transfer dictionary
        transfer_dict = deepcopy(self)
        
        # Remove all empty segments
        for key in self.multi.keys():
            if key.is_empty():
                transfer_dict.multi.pop(key)
        
        return transfer_dict
                
    def clean_ordering(self):
        """
        Cleans the multisegment ordering by removing any empty segments
        """
        # Remove all empty segments
        ordering = [seg for seg in self.ordering if not seg.is_empty()]
        
        return Multisegment(ordering, segs = True)
                
    def get_ordering(self):
        """
        Returns the multisegment's ordering list
        """
        return deepcopy(self.ordering)
    
    def get_dict(self):
        """
        Returns the multisegment's dictionary
        """
        return deepcopy(self.multi)
    
#     def get_lessThans(self):
#         """
#         Returns the multisegment's less thans list
#         """
#         return deepcopy(self.less_thans)
    
    def get_least(self):
        """
        Returns the unique minimal element
        """
        
        self.compute_less_thans()
        
        pos = Poset(data = (self.less_thans.values(), self.rel))
        
        return list(self.less_thans.keys())[list(self.less_thans.values()).index(pos.bottom())]
    
    def get_map(self):
        """
        Returns the map associated with the multisegment
        """
        
        # Define multi-segment map which returns the multiplicity of an occurence of an integer in the multisegment
        f = lambda x: sum([self.multi[key] for key in self.multi.keys() if key.contains(x)])
        
        return f
    
    def get_rel(self):
        """
        Returns the multisegment's less than relations for the poset with it as a maxima
        """
        return deepcopy(self.rel)

    
    def get_dual(self):
        """
        Computes the dual of our multisegment and returns its segment list
        """
        
        # Initializes list of segments defining dual
        segment_list = []
        
        # Initializes list of segments for storing the Delta_i in the current step
        current_segs = []
        
        # Initialize a boolean for the while loop
        iterate = True
        
        # Obtain a list of all segments in the current multisegment
        key_list = self.multi.keys()
        # Initialize the maximum end value and the current step maximum value
        e_max_orig = max([seg.get_segment_upper() for seg in key_list])
        e_max = e_max_orig
        
        # Initialize list of segments ending in the max value
        seg_list = [seg for seg in key_list if seg.get_segment_upper() == e_max]
        
        # Iterate until the list of Delta_i's is exhausted
        while iterate:
            # Initialize a list of beginning values of segments with the appropriate ends
            bottom_list = [seg.get_segment_lower() for seg in seg_list]
            # Find the index of a segment with the largest bottom value
            index = np.argmax(np.array(bottom_list))
            # Obtain the segment with the appropriate end and the largest bottom and append it to the current_segs list
            seg_e_max = deepcopy(seg_list[index])
            current_segs.append(seg_e_max)
            
            # Set the next segs list as those preceeding the current segment with a end of one less
            seg_list = [seg for seg in key_list if seg.precedes(seg_e_max) and seg.get_segment_upper() == e_max - _sage_const_1 ]
            
            # If the new seg list is empty end the iteration, otherwise decrease the max segment end value
            if seg_list == []:
                iterate = False
            else:
                e_max = e_max -_sage_const_1 
        
        # Append the segment going from e_max to e_max_orig to our list for the dual
        segment_list.append(Segment(e_max,e_max_orig))
        
        # Initialize list for storing segments in the next step of the iteration
        next_seg_list = []
        
        # Stores those the Delta_i's with their end cut off, as well as all other segments without any alteration
        for seg in self.multi.keys():
            if seg in current_segs:
                next_seg_list.extend([seg.subtract()])
                next_seg_list.extend((self.multi[seg]-_sage_const_1 )*[seg])
            else:
                next_seg_list.extend(self.multi[seg]*[seg])
        
        # Create a new multisegment and clean its dictionary and ordering lists from any empty segments
        new_multi = Multisegment(next_seg_list, segs=True)
        new_multi = new_multi.clean_dict()
        new_multi = new_multi.clean_ordering()
        
        # Return the current segment list if the new multisegment is empty, and repeat the recursion otherwise.
        if new_multi.get_ordering() == []:
            return segment_list
        else:
            segment_list.extend(new_multi.get_dual())
            
            return segment_list
        
        
    
    def elem_opp(self, seg1, seg2, i = -_sage_const_1 , j = -_sage_const_1 ):
        """
        Performs an elementary operation on our multisegment for the two
        segments seg1 and seg2. If i and j are specified they correspond with the 
        locations of seg1 and seg2 respectively.
        
        Parameters
        ----------
        seg1 : segment
            first segment in the elementary operation
        seg2 : segment
            second segment in the elementary operation
        i : int
            if specified, the index of seg1 in the multisegment's ordering
        j : int
            if specified, the index of seg2 in the multisegment's ordering
        """
        
        # Compute the union and intersection of the segments
        union = seg1.union(seg2)
        intersect = seg1.intersect(seg2)

        # Add the union and intersection segments to the multiset, or 
        # increment their index if they're already in there.
        for seg in [union, intersect]:
            if seg in self.multi.keys() and not seg.is_empty():
                self.multi[seg] += _sage_const_1 
            elif not seg.is_empty():
                self.multi[seg] = _sage_const_1 

        # Replaces seg1 by the union and seg2 by the intersection, if it's not empty
        for (sega, segb, k) in [(seg1,union, i),(seg2,intersect,j)]:
            # Remove sega if it has multiplicity 1, or reduces its multiplicity by 1
            if self.multi[sega] == _sage_const_1 :
                self.multi.pop(sega)
            else:
                self.multi[sega] -= _sage_const_1 

            # If the index k wasn't specified, set it to the first occurence of sega
            if k < _sage_const_0 :
                index = self.ordering.index(sega)
            else:
                index = k

            # If segb isn't empty add it to the ordering at the specified index,
            # else simply remove the segment at that index
            if not segb.is_empty():
                self.ordering[index] = segb
            else:
                self.ordering.pop(index)
    
    
    
    def least(self):
        """
        Checks if there are any linked segments in the multisegment. 
        If there are linkages possible, the multisegment is not "least",
        so we return False, and otherwise we return True
        """
        # Check all pairs of segments in the multisegment to see if any are linked
        for seg1 in self.multi.keys():
            for seg2 in self.multi.keys():
                if seg1.linked(seg2):
                    return False
                
        return True
    
    def recurse(self, current_multiseg, index_list):
        """
        Recursively computes the multisegments less than the current multisegment
        using the multisegments less than current_array.
        
        Parameters
        ----------
        current_multiseg : multisegment
            current multisegment we are computing the segments less than
        """
        # Iterates over each pair of distinct segments in current_array
        for i in range(len(current_multiseg.ordering)-_sage_const_1 ):
            for j in range(i+_sage_const_1 ,len(current_multiseg.ordering)):
                # If the pair of segments are linked, perform an elementary operation and recurse
                if current_multiseg.ordering[i].linked(current_multiseg.ordering[j]):
                    # Make a copy of the current multisegment
                    copy_multiseg = deepcopy(current_multiseg)
                    
                    # Perform the elementary operation on the copied multisegment
                    copy_multiseg.elem_opp(copy_multiseg.ordering[i], copy_multiseg.ordering[j], i = i, j = j)
                    
                    # If the resulting multisegment after the elementary operation is not already
                    # in the less thans list, append it to the end
                    if not copy_multiseg in self.less_thans.keys(): 
                        self.less_thans[copy_multiseg] = "a"+str(index_list)
                        # Find all segments less than copy_multiseg
                        self.recurse(copy_multiseg, copy(index_list) + [_sage_const_1 ])
                        # Increment the current row index
                        index_list[-_sage_const_1 ] = index_list[-_sage_const_1 ] + _sage_const_1 
                    
                    if not (self.less_thans[copy_multiseg], self.less_thans[current_multiseg]) in self.rel: 
                        self.rel.append((self.less_thans[copy_multiseg], self.less_thans[current_multiseg]))
                    
                
    
    def compute_less_thans(self):
        """
        Computes the list of multisegments less than the current one
        """
        # If the list has not already been computed, compute it
        if not self.is_computed():
            # Create a copy of the multisegment itself and add it to the list
            current_copy = deepcopy(self)
            self.less_thans[current_copy] = "a"
            
            # Apply recurse to find all multisegments less than self
            self.recurse(current_copy, [_sage_const_1 ])
            self.rel = list(Poset(data = (self.less_thans.values(), self.rel)).relations_iterator(strict = True))
            
            # Set the computed flag to true
            self.less_thans_computed = True
    
    
    def is_computed(self):
        """
        Returns if the multisegment's less than list has been computed
        """
        return self.less_thans_computed
            
    def get_less_thans(self):
        """
        Returns the multisegment's less than list and print it
        """
        return deepcopy(self.less_thans)
        
    def greater_than(self, other):
        """
        Returns if the inputted multisegment is less than the current multisegment
        
        Parameters
        ----------
        other : multisegment
            the multisegment being compared with
        """
        
        self.compute_less_thans()
        
        if other in self.less_thans.keys():
            return (self.less_thans[other], self.less_thans[self]) in self.rel or [self.less_thans[other], self.less_thans[self]] in self.rel
        else:
            return False
    

    def plot_poset(self):
        """
        Plots the multiset as a partially ordered set
        """
        self.compute_less_thans()
        
        # Initializes an array of labels for the multisegments in less_thans 
        # and an associated dictionary
        pos = Poset(data = (self.less_thans.values(), self.rel))
        
        print(len(self.less_thans.items()), "multisegments:")
        # Print the labels with their multisegment if there are less than 100
        for multi,label in self.less_thans.items():
            print(label + " = " + repr(multi))
        if len(self.less_thans.items()) < _sage_const_100 :
            # Plot the partially ordered set
            p_plot = pos.plot(figsize=_sage_const_12 , element_shape = "None", vertex_size = _sage_const_500 , title = repr(self) + " Poset Tree")
            show(p_plot)
        else:
            print("Too many multisegments to appropriately plot poset. "  
                  +"""To find relations between individual multisegments in the above list go to "Interactive_Multi_Order".""")
    
    def print_poset(self):
        """
        Prints the multiset
        """
        self.compute_less_thans()
        print(len(self.less_thans.items()), "multisegments:")
        # Print the labels with their multisegment if there are less than 100
        for multi,label in self.less_thans.items():
            print(label + " = " + repr(multi))
        
    
    def __repr__(self):
        """
        Represent a multisegment as a list of the segment representations
        """
        return self.ordering.__repr__()
    
    def string_format(self):
        """
        Defines a string representing the multisegment as a list of the segment 
        representations.
        """
        # Initialize the string with a left bracket
        s = "["
        for i in range(len(self.ordering)):
            # Append the string format of the ith segment
            s += self.ordering[i].string_format()
            
            # If we aren't at the end of the ordering list, add a comma
            if i < len(self.ordering)-_sage_const_1 :
                s += ", "
                
        # End the string with a right bracket
        s += "]"
        return s
    
    def __str__(self):
        """
        Shows the string representation of the multisegment when asked to print it
        """
        show(self.string_format())
        return ""
        
        
        
class MultisegmentQuot:
    """
    A class used to symbolically represent a multisegment of cuspidal representations

    ...

    Attributes
    ----------
    multi : dict
        a dictionary for storing the segments in our multisegments and their multiplicity
    ordering : list
        a list for storing the ordering of our segments
    less_thans_computed : bool
        a boolean specifying if the less_thans list has been computed for this multisegment
    less_thans : list
        a list of all multisegments less than the current multisegment
    rel : list
        a list of pairs of multisegments in less_thans describing the order relation between them

    Methods
    -------
    get_support()
        Returns the support of the multisegment as a multiset
    get_max()
        Returns the maximum multisegment associated with the current support
    get_max_int()
        Returns the highest segment upper bound in the multisegment
    get_min_int()
        Returns the lowest segment lower bound in the multisegment
    get_shift()
        Returns a multisegment of the same shape shifted by a specified amount
    subtract()
        Reduces the upper bound of each segment by 1
    clean_dict()
        Removes any empty segments in the dictionary
    clean_ordering()
        Removes any empty segments in the ordering list
    get_ordering()
        Returns a copy of the ordering list
    get_dict()
        Returns a copy of the segment dictionary
    get_less_thans()
        Returns a copy of the list of multisegments less than the current one
    get_least()
        Returns the smallest multisegment less than the current one
    get_map()
        Return the map associated with the multisegment
    get_rel()
        Returns the multisegments less than relation list
    get_dual()
        Returns the dual of the multisegment using the Moeglin-Waldspurger algorithm
    elem_opp()
        Performs an elementary operation on your multisegment for two given linked segments inside it
    least()
        Returns True if the multisegment has no linked segments, and hence has no multisegments less than it
    compute_less_thans()
        Computes the list of multisegments less than the current one
    recurse()
        A helper function for compute_less_thans()
    is_computed()
        Checks if compute_less_thans() has been run
    greater_than()
        Returns if the inputted multisegment is less than the current multisegment
    plot_poset()
        Plots the poset tree of multisegments less than or equal to the current one
    print_poset()
        Prints the multisegments less than or equal to the current one
    string_format()
        Defines a string representing the multisegment
    """
    def __init__(self, index_array, segs = False):
        """
        Initializes the multisegment and its segment components
        
        Parameters
        ----------
        index_array : list
            a list of index tuples for specifying segments (if segs = False), or a list
            of segments
        segs : bool, optional
            a boolean to specify if the inputted input array is an array of segments
        """
        
        # Initializes a dictionary for storing segments
        self.multi = {}
        # Initializes a list for storing the ordering of segments
        self.ordering = []
        
        if segs: 
            # If a segment list was giving set the ordering as equal to it
            self.ordering = index_array
            
            # For each segment in the index array, add it to the multi dictionary along with its multiplicity
            for seg in index_array:
                if seg in self.multi.keys():
                    self.multi[seg] += _sage_const_1 
                else:
                    self.multi[seg] = _sage_const_1 
        else:
            # For each pair of indices in the index array
            for pair in index_array:
                # Create a segment with lower and upper bounds specified by pair
                seg = Segment(pair[_sage_const_0 ], pair[_sage_const_1 ])
                
                # Either add the segment to the multi dictionary or increment its multiplicity
                if seg in self.multi.keys():
                    self.multi[seg] += _sage_const_1 
                else:
                    self.multi[seg] = _sage_const_1 
                # Append the segment to the ordering list
                self.ordering.append(seg)
            
        # Initializes the less_thans_computed flag to False
        self.less_thans_computed = False
        # Initializes dicitonary for storing multisegments less than the current one
        self.less_thans = {}
        self.greater_thans = {}
        
        # Initializes a list for storing the order relations between multisegments in less_thans
        self.rel = []
        self.relLess = []
        
    
    def __hash__(self):
        """
        Defines the hash for a multisegment using the hash of its segments
        """
        return hash(tuple(sorted(self.ordering)))
    
    def __eq__(self, other):
        """
        Defines when two multisegments are equal
        
        Parameters
        ----------
        other : multisegment
            the multisegment being compared with
        """
        # If the two multisegments have the same dictionary then they are equal
        if other.get_dict() == self.get_dict():
            return True
        else:
            return False
    
    
    def __ne__(self, other):
        """
        Defines when two multisegments are not equal
        
        Parameters
        ----------
        other : multisegment
            the multisegment being compared with
        """
        
        return not self.__eq__(other)
    
    def __add__(self, other):
        """
        Defines the addition of two multisegments by concatenating their 
        ordering arrays
        
        Parameters
        ----------
        other : multisegment
            the multisegment being compared with
        """
        
        return MultisegmentQuot(self.get_ordering()+other.get_ordering(), segs = True)
    
    def __lt__(self, other):
        """
        Defines when a multisegment is less than another (for quotients)
        
        Parameters
        ----------
        other : multisegment
            the multisegment being compared with
        """
        
        return self.greater_than(other)
    
    def __le__(self,other):
        """
        Defines when a multisegment is less than or equal to another (for quotients)
        
        Parameters
        ----------
        other : multisegment
            the multisegment being compared with
        """
        
        return self < other or self == other
    
    def get_support(self):
        """
        Returns the support of the multisegment
        """
        
        # Initialize dictionary for the support
        support = {}
        
        # Adds the multiplicity of each term in each segment to the support
        for seg, multiplicity in self.multi.items():
            for j in range(int(2*seg.get_segment_lower()),int(2*seg.get_segment_upper()+_sage_const_1), 2):
                if j/2 in support.keys():
                    support[j/2] += multiplicity
                else:
                    support[j/2] = multiplicity
        
        return support
                
    
    def get_max(self):
        """
        Returns the maximum multisegment associated with the current multisegment
        """
        
        multi_temp = Multisegment(self.get_ordering(), segs = True)
        
        multi_max = multi_temp.get_least()
        
        return MultisegmentQuot(multi_max.get_ordering(), segs = True)
    
    def get_min(self):
        """
        Returns the minimum multisegment associated with the current multisegment
        """
        # Get the support of the current multisegment
        support = self.get_support()
        
        # Creates a list of basic segments associated with the support of our segment
        input_list = [Segment(j,j) for (j,num) in support.items() for i in range(num)]
        
        # Returns the maximum multisegment
        return MultisegmentQuot(input_list, segs = True)
                
    def get_max_int(self):
        """
        Returns the highest index in the segments of the multisegment
        """
        
        max_list = [seg.get_segment_upper() for seg in self.multi.keys()]
        
        return max(max_list)
    
    def get_min_int(self):
        """
        Returns the lowest index in the segments of the multisegment
        """
        
        min_list = [seg.get_segment_lower() for seg in self.multi.keys()]
        
        return min(min_list)
    
    def get_shift(self, shift):
        """
        Returns a shifted multisegment
        """
        
        # Creates a list of basic segments associated with the support of our segment
        input_list = [Segment(seg.get_segment_lower()+shift,seg.get_segment_upper()+shift)
                      for (seg,num) in self.multi.items() for i in range(num)]
        
        # Returns the maximum multisegment
        return MultisegmentQuot(input_list, segs = True)
    
    
    def subtract(self):
        """
        Reduces the upper bound of each segment in the multisegment by 1. If the upper bound
        goes below the lower bound for any segment, set the segment as empty.
        """
        
        # Initialize transfer dictionary
        transfer_dict = {}
        for key in multi.keys():
            # Replace each segment by its subtraction
            transfer_dict[key.subtract()] = self.multi[key]
        
        # Replace the current dictionary with the transfer dictionary
        self.multi = transfer_dict
        
        # Replace current ordering with the subtracted segment ordering
        self.ordering = [seg.subtract() for seg in self.ordering]
        
        # Cleans the multiset and ordering of empty segments
        self.clean_dict()
        self.clean_ordering()
    
    def clean_dict(self):
        """
        Cleans the multisegment by removing any empty segments
        """
        
        # Initialize transfer dictionary
        transfer_dict = deepcopy(self)
        
        # Remove all empty segments
        for key in self.multi.keys():
            if key.is_empty():
                transfer_dict.multi.pop(key)
        
        return transfer_dict
                
    def clean_ordering(self):
        """
        Cleans the multisegment ordering by removing any empty segments
        """
        # Remove all empty segments
        ordering = [seg for seg in self.ordering if not seg.is_empty()]
        
        return Multisegment(ordering, segs = True)
                
    def get_ordering(self):
        """
        Returns the multisegment's ordering list
        """
        return deepcopy(self.ordering)
    
    def get_dict(self):
        """
        Returns the multisegment's dictionary
        """
        return deepcopy(self.multi)
    
#     def get_lessThans(self):
#         """
#         Returns the multisegment's less thans list
#         """
#         return deepcopy(self.less_thans)
    
    def get_map(self):
        """
        Returns the map associated with the multisegment
        """
        
        # Define multi-segment map which returns the multiplicity of an occurence of an integer in the multisegment
        f = lambda x: sum([self.multi[key] for key in self.multi.keys() if key.contains(x)])
        
        return f
    
    def get_rel(self):
        """
        Returns the multisegment's less than relations for the poset with it as a maxima
        """
        return deepcopy(self.relLess)

    def elem_opp(self, seg1, seg2, i = -_sage_const_1 , j = -_sage_const_1 ):
        """
        Performs an elementary operation on our multisegment for the two
        segments seg1 and seg2. If i and j are specified they correspond with the 
        locations of seg1 and seg2 respectively.
        
        Parameters
        ----------
        seg1 : segment
            first segment in the elementary operation
        seg2 : segment
            second segment in the elementary operation
        i : int
            if specified, the index of seg1 in the multisegment's ordering
        j : int
            if specified, the index of seg2 in the multisegment's ordering
        """
        
        # Compute the union and intersection of the segments
        union = seg1.union(seg2)
        intersect = seg1.intersect(seg2)

        # Add the union and intersection segments to the multiset, or 
        # increment their index if they're already in there.
        for seg in [union, intersect]:
            if seg in self.multi.keys() and not seg.is_empty():
                self.multi[seg] += _sage_const_1 
            elif not seg.is_empty():
                self.multi[seg] = _sage_const_1 

        # Replaces seg1 by the union and seg2 by the intersection, if it's not empty
        for (sega, segb, k) in [(seg1,union, i),(seg2,intersect,j)]:
            # Remove sega if it has multiplicity 1, or reduces its multiplicity by 1
            if self.multi[sega] == _sage_const_1 :
                self.multi.pop(sega)
            else:
                self.multi[sega] -= _sage_const_1 

            # If the index k wasn't specified, set it to the first occurence of sega
            if k < _sage_const_0 :
                index = self.ordering.index(sega)
            else:
                index = k

            # If segb isn't empty add it to the ordering at the specified index,
            # else simply remove the segment at that index
            if not segb.is_empty():
                self.ordering[index] = segb
            else:
                self.ordering.pop(index)
    
    
    
    def least(self):
        """
        Checks if there are any linked segments in the multisegment. 
        If there are linkages possible, the multisegment is not "least",
        so we return False, and otherwise we return True
        """
        # Check all pairs of segments in the multisegment to see if any are linked
        for seg1 in self.multi.keys():
            for seg2 in self.multi.keys():
                if seg1.linked(seg2):
                    return False
                
        return True
    
    def recurse(self, current_multiseg, index_list):
        """
        Recursively computes the multisegments greater than the current multisegment
        using the multisegments greater than current_array.
        
        Parameters
        ----------
        current_multiseg : multisegment
            current multisegment we are computing the segments less than
        """
        # Iterates over each pair of distinct segments in current_array
        for i in range(len(current_multiseg.ordering)-_sage_const_1 ):
            for j in range(i+_sage_const_1 ,len(current_multiseg.ordering)):
                # If the pair of segments are linked, perform an elementary operation and recurse
                if current_multiseg.ordering[i].linked(current_multiseg.ordering[j]):
                    # Make a copy of the current multisegment
                    copy_multiseg = deepcopy(current_multiseg)
                    
                    # Perform the elementary operation on the copied multisegment
                    copy_multiseg.elem_opp(copy_multiseg.ordering[i], copy_multiseg.ordering[j], i = i, j = j)
                    
                    # If the resulting multisegment after the elementary operation is not already
                    # in the less thans list, append it to the end
                    if not copy_multiseg in self.greater_thans.keys(): 
                        self.greater_thans[copy_multiseg] = "a"+str(index_list)
                        # Find all segments less than copy_multiseg
                        self.recurse(copy_multiseg, copy(index_list) + [_sage_const_1 ])
                        # Increment the current row index
                        index_list[-_sage_const_1 ] = index_list[-_sage_const_1 ] + _sage_const_1 
                    
                    if not (self.greater_thans[current_multiseg], self.greater_thans[copy_multiseg]) in self.rel: 
                        self.rel.append((self.greater_thans[current_multiseg], self.greater_thans[copy_multiseg]))
                    
                
    
    def compute_greater_thans(self):
        """
        Computes the list of multisegments greater than the current one
        """
        # If the list has not already been computed, compute it
        if not self.is_computed():
            # Create a copy of the multisegment itself and add it to the list
            current_copy = deepcopy(self)
            self.greater_thans[current_copy] = "a"
            
            # Apply recurse to find all multisegments less than self
            self.recurse(current_copy, [_sage_const_1 ])
            self.rel = list(Poset(data = (self.greater_thans.values(), self.rel)).relations_iterator(strict = True))
            
            # Set the computed flag to true
            self.less_thans_computed = True
            
    def compute_less_thans(self):
        """
        Computes the list of multisegments less than the current one
        """
        min_multi = self.get_min()
        
        min_multi.compute_greater_thans()
        self.less_thans = dict([(multi, name) for (multi,name) in min_multi.greater_thans.items() if multi <= self])
        self.relLess = [[name1,name2] for [name1,name2] in min_multi.rel if name1 in self.less_thans.values() and name2 in self.less_thans.values()]
    
    def is_computed(self):
        """
        Returns if the multisegment's less than list has been computed
        """
        return self.less_thans_computed
            
    def get_less_thans(self):
        """
        Returns the multisegment's less than list and print it
        """
        return deepcopy(self.less_thans)
        
    def greater_than(self, other):
        """
        Returns if the inputted multisegment is less than the current multisegment
        
        Parameters
        ----------
        other : multisegment
            the multisegment being compared with
        """
        
        self.compute_greater_thans()
        
        if other in self.greater_thans.keys():
            return (self.greater_thans[self], self.greater_thans[other]) in self.rel or [self.greater_thans[self], self.greater_thans[other]] in self.rel
        else:
            return False
    

    def plot_poset(self):
        """
        Plots the multiset as a partially ordered set
        """
        self.compute_less_thans()
        
        # Initializes an array of labels for the multisegments in less_thans 
        # and an associated dictionary
        pos = Poset(data = (self.less_thans.values(), self.relLess))
        
        print(len(self.less_thans.items()), "multisegments:")
        # Print the labels with their multisegment if there are less than 100
        for multi,label in self.less_thans.items():
            print(label + " = " + repr(multi))
        if len(self.less_thans.items()) < _sage_const_100 :
            # Plot the partially ordered set
            p_plot = pos.plot(figsize=_sage_const_12 , element_shape = "None", vertex_size = _sage_const_500 , title = repr(self) + " Poset Tree")
            show(p_plot)
        else:
            print("Too many multisegments to appropriately plot poset. "  
                  +"""To find relations between individual multisegments in the above list go to "Interactive_Multi_Order".""")
    
    def print_poset(self):
        """
        Prints the multiset
        """
        self.compute_less_thans()
        print(len(self.less_thans.items()), "multisegments:")
        # Print the labels with their multisegment if there are less than 100
        for multi,label in self.less_thans.items():
            print(label + " = " + repr(multi))
        
    
    def __repr__(self):
        """
        Represent a multisegment as a list of the segment representations
        """
        return self.ordering.__repr__()
    
    def string_format(self):
        """
        Defines a string representing the multisegment as a list of the segment 
        representations.
        """
        # Initialize the string with a left bracket
        s = "["
        for i in range(len(self.ordering)):
            # Append the string format of the ith segment
            s += self.ordering[i].string_format()
            
            # If we aren't at the end of the ordering list, add a comma
            if i < len(self.ordering)-_sage_const_1 :
                s += ", "
                
        # End the string with a right bracket
        s += "]"
        return s
    
    def __str__(self):
        """
        Shows the string representation of the multisegment when asked to print it
        """
        show(self.string_format())
        return ""
        
        
def left_least(A, min_row = _sage_const_0 ):
    """
    Returns the lowest and left most non-zero element of A along with its indices,
    where A is organized as being lower triangular with corresponding rows ordered
    from bottom left up.
    
    The returned variables are the value of the left-least entry, its matrix row and its matrix column
    
    Parameters
    ----------
    A : matrix
        the lower triangular matrix containing rank triangle data
    min_row : integer
        the minimum non-zero row of the rank triangle, initialized to zero being the bottom point of the triangle
    """
    
    # Initialize number of columns of A
    n = np.shape(A)[_sage_const_0 ]
    # For each triangle row in the given range
    for i in range(min_row, n):
        # For each entry of the current triangle row, if the entry is non-zero return it
        for j in range(_sage_const_0 ,i+_sage_const_1 ):
            
            # Note n-1-i+j gives the matrix row associated with the entry, while j gives both
            # the matrix and triangle column
            if A[n-_sage_const_1 -i+j,j] != _sage_const_0 :
                return A[n-_sage_const_1 -i+j,j], n-_sage_const_1 -i+j, j
                

def one_triag(n):
    """
    Creates a lower triangular array of ones and returns it
    
    Parameters
    ----------
    n : int
        the size of the square matrix
    """
    
    # Initializes a square nxn array of ones
    T = np.ones((n,n))
    
    # Zero terms above the diagonal
    T = np.tril(T, k=_sage_const_0 )
    
    return T
    
    
    
def sub_triag_ones(n, i, j):
    """
    Creates an nxn matrix with a lower-triangular sub-triangle with peak at [j,i]
    in rank triangle notation, or embedded between the j-i row and columns
    
    Parameters
    ----------
    n : int
        the size of the matrix
    i : int
        the upper bound of the lower-triangular one block
    j : int
        the lower bound of the lower-triangular one block
    """
    # Initializes subtriangle
    T = one_triag(i+_sage_const_1 -j)
    
    # Initializes array of zeros
    B = np.zeros((n,n))
    
    # Sets subsquare of the array to T
    B[j:i+_sage_const_1 ,j:i+_sage_const_1 ] = T
    
    return B
    
    
    
def multi_segment(A, e_bot):
    """
    Returns the multisegment associated with a rank triangle A
    along with its eigen list
    
    Parameters
    ----------
    A : matrix
        the lower triangular matrix containing rank triangle data
    e_bot : float
        the smallest value in the infinitesimal parameter defining the Vogan
    """
    
    # Initialize the dictionary for the multisegment
    ordering = []
    
    # Initialize rank-sub matrix
    rank_matr = A
    
    # Initialize the minimum row number and the number of columns in rank_matr
    n = np.shape(rank_matr)[_sage_const_0 ]
    min_row = _sage_const_0 
    
    # Loop while A is not the zero matrix and has only non-negative entries
    while (not np.all(rank_matr == _sage_const_0 )) and np.all(rank_matr >= _sage_const_0 ):
        # Find the value and indices where the left-most and lowest left-upper-triangular entry is
        k, i, j = left_least(rank_matr, min_row)
        
        # Create a submatrix with a subtriangle centered at our found entry
        rank_ones = sub_triag_ones(n, i, j)
        
        # Update the minimum row to the current row
        min_row = j+(n-i-_sage_const_1 )
        
        # Store the value in the entry with a segment key
        ordering.extend([Segment(j+e_bot, i+e_bot) for l in range(int(k))])
        
        # Subtract off the triangles centered at i,j until rank_matr[i,j] = 0
        rank_matr = rank_matr - k*rank_ones
        
        # If the entries in the array went negative it cannot be a rank triangle, so notify the user and return
        if np.any(rank_matr < _sage_const_0 ):
            print("Error:" + str(A) + " is not a rank triangle")
            return
        
    # Initialize multisegment from the ordering list
    m = Multisegment(ordering, segs = True)
    
    # Return the multisegment
    return m
    
    
    
def rank_triang_array(rank_str):
    """
    Builds a rank triangle from a rank string
    with the main diagonal containing the dimensions of eigenspaces
    
    Parameters
    ----------
    rank_str : str
        a string containing rank data
    
    Example input: (-1,0,1), {2,4,2}, {{1,1}, {1}}
    """
    
    # Regular expression for eigen_string
    reg_eigen = r'\([\-?\+?\d+\.?\d*,]*[-+]?\d+\.?\d*\)'
    # Regular expression for a list of rank triangle information
    reg = r'\{[0-9,]*[0-9]\}'
    
    # Obtain eigen string
    eigen = re.findall(reg_eigen, rank_str)[_sage_const_0 ]
    
    # Obtains a list of all input lists
    str_list = re.findall(reg, rank_str)
    
    # Obtain list of eigenvalues
    eigen_list = [float(i) for i in re.findall(r'[-+]?\d+\.?\d*', eigen)]
    
    # Obtains the list of lists of integers in the input
    int_lists = [[int(i) for i in re.findall(r'\d',input_str)] for input_str in str_list]
    
    # Sets the row number as the number of eigenspaces
    row_num = len(int_lists[_sage_const_0 ])
    
    # Initializes an array of zeros
    rank_triang = np.zeros((row_num, row_num))
    
    # Fills the lower diagonals of the array with rank triangle information
    for i in range(_sage_const_0 ,row_num):
        rank_triang = rank_triang + np.diag(np.array(int_lists[i]), k = -i)
    
    # Return rank triangle array
    return rank_triang, eigen_list
    
    
def rank_str(rank_triang_array, e_list):
    """
    Obtain the input string corresponding with a rank triangle and eigenvalue list
    
    Parameters
    ----------
    rank_triang_array : matrix
        the lower triangular matrix containing rank triangle data
    e_list : list
        list of floats describing the infinitesimal parameter of our Vogan
    """
    
    # Initialze row number
    row_num = np.shape(rank_triang_array)[_sage_const_0 ]
    
    output_str = '(' + ','.join([str(int(j)) for j in e_list]) + ')'
    # Creates the string associated with the rank triangle stored in the lower triangular portion of the matrix
    for i in range(row_num):
        # Joins the integers on the ith diagonal below the main diagonal
        cur_str = ','.join([str(int(j)) for j in np.diag(rank_triang_array, k = -i)])
        cur_str = '{' + cur_str + '}'
        
        # Add the current string to the output
        output_str += cur_str
        
        # Add an ending or starting brace if we are at the start or end of the input, or add a comma
        if i == _sage_const_0 :
            output_str += ','+'{'
        elif i != row_num-_sage_const_1 :
            output_str += ','
        else:
            output_str += '}'
    
    # Return the rank triangle string
    return output_str
    
    
    
def triag_to_list(triag_str, eigenvalue_row = False):
    """
    Obtains the input string associated with a triangle string
    
    output format: (e_k,...,e_0),{r_kk,...,r_00},{{r_kk-1,...,r_10},...,{r_k0}}
    
    Parameters
    ----------
    triag_str : str
        triangle shaped string for the current rank triangle
    eigenvalue_row : bool
        boolean marking whether the string contains a row for eigenvalues
    """
    
    # Initialize rows of integers in the rank triangle
    int_list = str(triag_str).split('\n')
    if eigenvalue_row:
        eigen = int_list[_sage_const_0 ]
        eigen = eigen.strip().split("   ")
        eigen = '('+','.join(eigen)+')'
        int_list = int_list[_sage_const_1 :]
        num_wors = len(int_list)
    else:
        num_rows = len(int_list)
        eigen =[str(i) for i in range(num_rows)]
        eigen = '('+','.join(eigen)+')'
        
        
    
    # Remove the spaces at the start of and between integers
    int_list = [int_list[i].strip().split("   ") for i in range(num_rows)]
    # Joins the integers in each row by commas
    int_list = [','.join(int_list[i]) for i in range(num_rows)]
    
    # Creates the string associated with the rank triangle
    output_str = eigen + ','
    for i in range(num_rows):
        # Adds the current row to the output string with braces around
        output_str += '{' + int_list[i] + '}'
        
        # Add an ending or starting brace if we are at the start or end of the input, or add a comma
        if i == _sage_const_0 :
            output_str += ','+'{'
        elif i != num_rows-_sage_const_1 :
            output_str += ','
        else:
            output_str += '}'
    
    # Return the rank triangle string
    return output_str
    
    
def array_to_triag(rank_array, eigen_list):
    """
    Returns the triangle string for a rank triangle from its array data
    
    Parameters
    ----------
    rank_array : matrix
        the lower triangular matrix containing rank triangle data
    eigen_list : list
        list of floats describing the infinitesimal parameter of our Vogan
    """
    
    # Initialze row number
    row_num = np.shape(rank_array)[_sage_const_0 ]
    
    output_str = '   '.join([str(j) for j in eigen_list])+'\n'
    # Creates the string associated with the rank triangle stored in the lower triangular portion of the matrix
    for i in range(row_num):
        # Joins the integers on the ith diagonal below the main diagonal
        cur_str = '   '.join([str(int(j)) for j in np.diag(rank_array, k = -i)])
        
        # Add the current string to the output
        output_str += i*"  " + cur_str
        
        # Add an ending or starting brace if we are at the start or end of the input, or add a comma
        if i != row_num-_sage_const_1 :
            output_str += '\n'
    
    # Return the rank triangle string
    return output_str
    
    
    
def rank_triag(multi_seg):
    """
    Returns the rank triangle associated with a multi-segment 
    
    Parameters
    ----------
    multi_seg : Multisegment
        A multisegment describing an orbit in a Vogan
    """
    
    # Initialize number of rows in the rank triangle
    row_num = int(multi_seg.get_max_int()-multi_seg.get_min_int()+_sage_const_1 )
    eigen_list = [x/2.0 for x in range(int(2*multi_seg.get_min_int()), int(2*multi_seg.get_max_int()+_sage_const_1), 2)]
    multi_seg = multi_seg.get_shift(_sage_const_1 -eigen_list[0])
    
    # Obtain the underlying dictionary for the multisegment
    multi_dict = multi_seg.get_dict()
    
    # Initialize array of zeros for the rank triangle
    rank_triang = np.zeros((row_num,row_num))
    for segment in multi_dict.keys():
        i = int(segment.get_segment_upper()-1) # Column index for tip of triangle
        j = int(segment.get_segment_lower()-1) # Row index for tip of triangle
        
        # Create a submatrix with a subtriangle cenetered at our found entry
        rank_ones = sub_triag_ones(row_num, i, j)
        
        # Adding multiplicity times the triangle associated with the current segment
        rank_triang = rank_triang + multi_dict[segment]*rank_ones
    
    return rank_triang, eigen_list


def triag_str_to_latex(triag_str, eigen_list, dollars = True):
    """
    Returns a latex_str for a rank triangle from its triangle string
    
    Parameters
    ----------
    triag_str : str
        triangle shaped string for the current rank triangle
    eigen_list : list
        list of floats describing the infinitesimal parameter of our Vogan
    dollars : bool
        boolean indicator for specifiying if the latex expression should be wrapped in $ signs
    """
    
    # Initialize the nested list of integer rows below the dimension line
    int_list = str(triag_str).split('\n')
    int_list = [[int(j) for j in int_list[i].strip().split('   ')] for i in range(1,len(int_list))]
    
    # Initialize a latex string for an array for the rank triangle
    if dollars:
        latex_str = r"$\begin{array}{" + (_sage_const_2 *len(int_list[_sage_const_0 ])-_sage_const_1 )*"c"+"}"
    else:
        latex_str = r"\begin{array}{" + (_sage_const_2 *len(int_list[_sage_const_0 ])-_sage_const_1 )*"c"+"}"
    
    # Adds the row of eigenvalues first
    latex_str += r" && ".join([str(round(x, 1)) for x in eigen_list]) + r"\\ \hline "
    
    # For each other row append i & symbols in front and behind for spacing, with two &'s for separating terms
    for i in range(len(int_list)):
        latex_str += i*r" & "
        for j in range(len(int_list[i])):
            latex_str += str(int_list[i][j])
            if j < len(int_list[i])-_sage_const_1 :
                latex_str += r" && "
        latex_str += i*r" & "
        
        if i == _sage_const_0:
            latex_str += r"\\ \hline"
        elif i != len(int_list)-_sage_const_1 :
            latex_str += r" \\ "
    if dollars:
        latex_str += r"\end{array}$"
    else:
        latex_str += r"\end{array}"
    
    return latex_str

def standard_seg(seg):
    """
    Returns a latex string visualizing the standard representation associated with a segment
    
    Parameters
    ----------
    seg : Segment
        the segment which is having its standard computed
    """
    
    # If the segment is of length one no induction is needed, otherwise induce from a borel
    # up to the suitable general linear group and take the unique quotient
    if seg.get_length() == 1:
        latex_str = r"\nu^{" + str(int(2*seg.get_segment_lower())/2) + r"}"
    elif seg.get_length() > 1:
        latex_str = r"Q\left(\text{ind}_{B}^{GL(" + str(int(seg.get_length())) + r")}\left("
        for i in range(int(2*seg.get_segment_lower()), int(2*seg.get_segment_upper() + 1), 2):
            latex_str += r" \nu^{" + str(i/2) + "} "
            if i < int(2*seg.get_segment_upper()):
                # Boxtimes is used to indicate external tensor products
                latex_str += r" \boxtimes "
            else:
                latex_str += r"\right)\right)"
        
    return latex_str

def standard_String(multi):
    """
    Returns a latex string visualizing the standard representation associated with a segment
    
    Parameters
    ----------
    seg : Segment
        the segment which is having its standard computed
    """
    
    # Initialize the dictionary for the multisegment
    multi_dict = multi.get_dict()
    
    # Create a sorted list of segments based on their upper and lower bounds
    segments = sorted(list(multi_dict.keys()), key = lambda seg: (seg.get_segment_lower(),seg.get_segment_upper()), reverse = True)
    
    # Initialize a list of segment lengths and sum them to get the size of our general linear group
    lengths = [int(seg.get_length()) for seg in segments for i in range(multi_dict[seg])]
    N = sum(lengths)
    
    # Initialize a list of strings for the lengths
    lengths_strs = [str(i) for i in lengths]
    
    # Create a string for inducing from the appropriate parabolic subgroup if there is more than one segment
    if len(segments) > 1 or multi_dict[segments[0]] > 1:
        latex_str = r"$\text{ind}_{P_{" + ",".join(lengths_strs) + r"}}^{GL(" + str(N) + r")}\left("
        for i in range(len(segments)):
            # Obtain the standard module for the current segment and add it to the string
            # for the number of times that segment appears in the multisegment
            seg = segments[i]
            seg_str = standard_seg(seg)
            latex_str += (multi_dict[seg]-1)*(seg_str + r" \boxtimes ") + seg_str # Boxtimes is used to indicate external tensor products

            if i < len(segments)-1:
                latex_str += r" \boxtimes "
            else:
                latex_str += r"\right)$"
    else:
        latex_str = r"$" + standard_seg(segments[0]) + r"$"
     
    display(Markdown(latex_str))

############# Dimension Functions

def rank_dim_Form(rank_triangle):
    """
    Returns the dimension of the stabilizer of a point in the orbit described 
    by a rank triangle using The Geometry of Representations of Am [ADFK] Lemma 3.2
    
    Parameters
    ----------
    rank_triangle : matrix
        the lower triangular matrix containing rank triangle data
    """
    
    # Initialize the number of rows
    row_num = len(rank_triangle)
    # Initialize the dimension sum to 0
    dim_sum = 0
    
    # Apply the double summation formula found in [ADFK] Lemma 3.2
    for i in range(row_num):
        for j in range(i,row_num):
            row = row_num-1 - i
            col = row_num-1 - j
            
            if row+1 == row_num:
                term2 = 0
            else: 
                term2 = rank_triangle[row+1,col]
            
            if col-1 == -1:
                term1 = 0
            else:
                term1 = rank_triangle[row,col-1]
            
            dim_sum += (rank_triangle[row,col] - term1)*(rank_triangle[row,col]-term2)
        
    return int(dim_sum)

def dim_orbit(rank_triangle):
    """
    Returns the dimension of the stabilizer of a point in the orbit described 
    by a rank triangle using the orbit stabilizer theorem
    
    Parameters
    ----------
    rank_triangle : matrix
        the lower triangular matrix containing rank triangle data
    """
    
    # Obtain the diagonal of eigen dimensions and sum their squares to get the dimension of H, the group acting on our space
    diagonal = np.diag(rank_triangle)
    square = np.vectorize(lambda x: x**2)
    squared_diagonal=square(diagonal)
    dimH = np.sum(squared_diagonal)
    
    # Obtain the dimension of the stabilizer of a point in the orbit
    dimStab = rank_dim_Form(rank_triangle)
    
    return dimH-dimStab
    
############# Widget Functions 
    
    
def parse_mseg_string(mseg_string, quot = False):
    """
    Creates a multisegment described in an inputted string
    """
    # Initialize list of segments in the string
    seg_list = []
    # Checks that the string is surrounded by square braces
    if re.match(r'^\[.*\]$', mseg_string):
        # Defines a regular expression for a segment of integers with arbitrary whitespace
        regex = r'\[\s*[-+]?\d+\.?\d*\s*,\s*[-+]?\d+\.?\d*\s*\]'
        regex2 = r'\[\s*[-+]?\d+\.?\d*\s*\]'
        
        # Obtain a list of all segments in the mseg_string using the regex
        tuple_list = re.findall(regex, mseg_string)
        singleton_list = re.findall(regex2, mseg_string)
        
        # Append a tuple for each segment in the list
        for pair in tuple_list:
            # Remove the non-integer characters in the string
            pair = pair.strip("[")
            pair = pair.strip("]")
            numbs = pair.split(",")
            # Append the tuple for the given segment to the list
            seg_list.append((float(numbs[_sage_const_0 ]), float(numbs[_sage_const_1 ])))
        
        # Append a tuple for each singleton segment in the list
        for singleton in singleton_list:
            singleton = singleton.strip("[")
            singleton = singleton.strip("]")
            # Append the tuple for the given segment to the list
            seg_list.append((float(singleton), float(singleton)))
        
    if quot:
        multi_seg = MultisegmentQuot(seg_list)
    else:
        # Create a multisegment from the list of segments as tuples
        multi_seg = Multisegment(seg_list)
   
    # Return the multisegment
    return multi_seg
    
    
    
def interactive_multisegment(mseg_string, quot):
    """
    Plots the poset for a multisegment inputted as a string
    """
    multi_seg = parse_mseg_string(mseg_string, quot)
    multi_seg.plot_poset()
    
    
def multi_tree_widget():
    """
    Creates an interactive widget for interactive_multisegment
    """
    im = widgets.interact_manual(interactive_multisegment, 
                 mseg_string = widgets.Textarea(value="[[0,0],[1,1]]", description = "Multisegment"),
                quot = widgets.Checkbox(value=False, description='Quotient:',disabled=False, indent=True));
    im.widget.children[_sage_const_2 ].description = "Run Algorithm"
    im.widget.children[_sage_const_2 ].style.button_color = 'violet'
    
    
    
def max_tree(mseg_string,quot):
    """
    Finds the maximal tree for a given multisegment
    """
    multi_seg = parse_mseg_string(mseg_string)
    print("Multisegment inputted:",repr(multi_seg))
    
    if quot:
        min_multi_seg = multi_seg.get_least()
        min_multi_seg = MultisegmentQuot(min_multi_seg.get_ordering(), segs=True)
        min_multi_seg.plot_poset()
    else:
        max_multi_seg = multi_seg.get_max()
        max_multi_seg.plot_poset()
        
        
        
def max_tree_widget():
    """
    Creates an interactive widget for max_tree
    """
    im = widgets.interact_manual(max_tree, 
                 mseg_string = widgets.Textarea(value="[[0,0],[1,1]]", description = "Multisegment"),
                quot = widgets.Checkbox(value=False, description='Quotient:',disabled=False, indent=True));
    im.widget.children[_sage_const_2 ].description = "Run Algorithm"
    im.widget.children[_sage_const_2 ].style.button_color = 'violet'
    
    
    
def multi_to_rank(mseg_string):
    """
    Prints the multisegment for a rank triangle
    """
    
    
    # Obtain multisegment and boolean indicator
    multi_seg= parse_mseg_string(mseg_string)
    
    # Create a rank triangle from the multisegment and the dimension list
    rank_array, eigen_list = rank_triag(multi_seg)
    
    # Print the rank triangle
    triag_str=array_to_triag(rank_array, eigen_list)
    latex_str = triag_str_to_latex(triag_str,eigen_list)
    # Display the latex array
    display(Markdown(latex_str))
    
    
    
def multi_to_rank_widget():
    """
    Creates an interactive widget for multi_to_rank
    """
    im = widgets.interact_manual(multi_to_rank, 
                 mseg_string = widgets.Textarea(value="[[2,3],[2,3],[4,4],[4,4],[1,1],[1,1]]", description = "Multisegment"));
    im.widget.children[_sage_const_1 ].description = "Run Algorithm"
    im.widget.children[_sage_const_1 ].style.button_color = 'violet'
    
    
    
def rank_to_multi(rank_str_input):
    """
    Obtain the multisegment and eigen_list for a rank triangle
    """
    rank_array, eigen_list = rank_triang_array(rank_str_input)
    m = multi_segment(rank_array, eigen_list[_sage_const_0 ])
    print("Multisegment:",repr(m))
    print("Eigen List:", eigen_list)
    
    
    
def rank_to_multi_widget():
    """
    Creates an interactive widget for rank_to_multi
    """
    im = widgets.interact_manual(rank_to_multi, 
                 rank_str_input = widgets.Textarea(value="(-2,-1,0,1,2),{2,4,4,4,2},{{2,3,3,2},{1,2,1},{1,1},{0}}", 
                                                   description = "Rank-Triangle"));
    im.widget.children[_sage_const_1 ].description = "Run Algorithm"
    im.widget.children[_sage_const_1 ].style.button_color = 'violet'
    
    
    
def multi_order(order_str, quotient = False):
    """
    Checks how two multisegments are related from a string.
    """
    
    # Initialize the result as false
    result = False
    
    # Initialize the separator in the string
    if '<=' in order_str:
        separator = '<='
    elif '>=' in order_str:
        separator = '>='
    elif '<' in order_str:
        separator = '<'
    elif '>' in order_str:
        separator = '>'
    elif '=' in order_str:
        separator = '='
    else: # If no valid comparator is in the string, return
        print("Invalid comparator")
        return
    
    # Split the string into two multisegments around the comparator
    multis = order_str.split(separator)
    multis[_sage_const_0 ] = multis[_sage_const_0 ].strip()
    multis[_sage_const_1 ] = multis[_sage_const_1 ].strip()
    
    # Initialize the multisegments from their strings
    multis[_sage_const_0 ] = parse_mseg_string(multis[_sage_const_0 ])
    multis[_sage_const_1 ] = parse_mseg_string(multis[_sage_const_1 ])
    
    # Set the order of the comparison
    if quotient:
        i = _sage_const_1 
        j = _sage_const_0 
    else:
        i = _sage_const_0 
        j = _sage_const_1 
    
    # Checks if the separators condition holds
    if separator == '<=':
        result = (multis[i] < multis[j]) or (multis[i]==multis[j])
    elif separator == '>=':
        result = (multis[i] > multis[j]) or (multis[i]==multis[j])
    elif separator == '<':
        result = (multis[i] < multis[j])
    elif separator == '>':
        result = (multis[i] > multis[j])
    elif separator == '=':
        result = (multis[i] == multis[j])
    
    # Prints the comparison and its truth value
    print(order_str + ":", result)
    
    
    
def multi_order_widget():
    """
    Creates an interactive widget for multi_order
    """
    im = widgets.interact_manual(multi_order, 
                 order_str = widgets.Textarea(value="[[0,0],[1,1]] < [[0,0],[1,1]]", description = "Relation:"),
                quotient = widgets.Checkbox(value=False, description='Quotient:',disabled=False, indent=True));
    im.widget.children[_sage_const_2 ].description = "Run Algorithm"
    im.widget.children[_sage_const_2 ].style.button_color = 'violet'
    
    
    
def multi_free_matr(mseg_string, mix, display_zeros = True, max_seg = False, print_multis = False):
    """
    Creates and displays the multiplicity matrix for a multiplicity free multisegment
    """
    # Initialize the multisegment
    multi_seg = parse_mseg_string(mseg_string)
    
    # Select the max multisegment if max_seg == True
    if max_seg:
        multi_seg = multi_seg.get_max()
    
    # Compute the poset for the multisegment
    multi_seg.compute_less_thans()
    
    # Check that the support of the multisegment is multiplicity free
    if not all(k == _sage_const_1  for k in multi_seg.get_support().values()):
        print("Support is not multiplicity free.")
        return
    
    # Creates a sorted less_thans dictionary associated with the multisegment
    less_thans = multi_seg.get_less_thans()
    less_thans = dict(sorted(less_thans.items(), key = lambda item: len(item[_sage_const_1 ])))
    
    # Obtains the list of multisegments in the poset plus its size
    key_list = list(less_thans.keys())
    num_keys = len(less_thans.keys())
    
    # Obtain the relations between the multisegments
    rels = multi_seg.get_rel()
    
    # Creates an array with 1's along the diagonal of size num_keys
    multi_arr = np.diag(np.ones(num_keys), k =_sage_const_0 )
    
    # Adjust the value of the entries in the matrix so that they are 1 if the column is less than the row
    for i in range(num_keys):
        for j in range(num_keys):
            if [less_thans[key_list[j]], less_thans[key_list[i]]] in rels:
                multi_arr[i,j] = _sage_const_1 
    
    string_rows = []
    # Appends the row of values in the matrix to the latex string array
    for i in range(num_keys):
        latex_str_row = r"\pi_L(" + less_thans[key_list[i]] + ") & "
        for j in range(num_keys):
            if multi_arr[i,j] == _sage_const_1 :
                latex_str_row += r"\color{red}" + str(int(multi_arr[i,j]))
            elif display_zeros:
                latex_str_row += str(int(multi_arr[i,j]))
            
            if j != num_keys -_sage_const_1 :
                latex_str_row += r" & "
            else:
                latex_str_row += r"\\ "
        string_rows.append(latex_str_row)
    
    # Change to duals if quot is given
    if mix:
        key_list = [Multisegment(multi.get_dual(), segs = True) for multi in key_list]
        # Initialize the multisegment
        multi_seg_max = multi_seg.get_max()
        # Creates a sorted less_thans dictionary associated with the multisegment
        multi_seg_max.compute_less_thans()
        less_thans = multi_seg_max.get_less_thans()
    
    # Initialize a latex string for an array along with its first line being 
    # the irreducible subreps
    latex_str = r"$\begin{array}{c|" + num_keys*"c"+"} & "
    for i in range(num_keys):
        if mix:
            latex_str += r"O("+less_thans[key_list[i]]+r")"
        else:
            latex_str += r"L("+less_thans[key_list[i]]+r")"
        if i != num_keys -_sage_const_1 :
            latex_str += r" & "
        else:
            latex_str += r"\\ \hline"
    
    # Appends the row of values in the matrix to the latex string array
    for row in string_rows:
        latex_str += row
    latex_str += r"\end{array}$"
    # Display the latex array
    display(Markdown(latex_str))
    
    # Print the poset if requested
    if print_multis:
        multi_seg.print_poset()
        
        
        
def multi_free_matr_widget():
    """
    Creates an interactive widget for multi_free_matr
    """
    im = widgets.interact_manual(multi_free_matr, 
                     mseg_string = widgets.Textarea(value="[[0,0],[1,1]]", description = "Multisegment"),
                    mix = widgets.Checkbox(value=False, description='Mix:',disabled=False, indent=True),
                    display_zeros = widgets.Checkbox(value=True, description='Zeros',disabled=False, indent=True),
                    max_seg = widgets.Checkbox(value=False, description='Max Matrix',disabled=False, indent=True),
                    print_multis = widgets.Checkbox(value=False, description='Print Multisegments',disabled=False, indent=True))
    im.widget.children[_sage_const_5 ].description = "Run Algorithm"
    im.widget.children[_sage_const_5 ].style.button_color = 'violet'
    
    
    
def dual_multi(mseg_string):
    """
    Obtains the dual multisegment and prints the result
    """
    
    # Initialize the multisegment
    multi_seg = parse_mseg_string(mseg_string)
    dual_multi = multi_seg.get_dual()
    print(repr(dual_multi))
    
    
    
def dual_multi_widget():
    """
    Creates an interactive widget for dual_multi
    """
    im = widgets.interact_manual(dual_multi, 
                 mseg_string = widgets.Textarea(value="[[0,0],[1,2]]", description = "Multisegment"));
    im.widget.children[_sage_const_1 ].description = "Run Algorithm"
    im.widget.children[_sage_const_1 ].style.button_color = 'violet'
    
    
    
def dual_rank(rank_str_input):
    """
    Obtains the dual rank triangle to the input and displays the result
    """
    
    # Obtain the rank array and eigen list, as well as the associated multisegment
    # and its dual
    rank_array, eigen_list = rank_triang_array(rank_str_input)
    multi_seg = multi_segment(rank_array, eigen_list[_sage_const_0 ])
    dual_multi = Multisegment(multi_seg.get_dual(), segs = True)
    
    # Initialize shift number
    shift = _sage_const_0 
    
    # Create a rank triangle from the multisegment and the dimension list
    rank_array, eigen_list = rank_triag(dual_multi)
    
    # Print the rank triangle
    triag_str=array_to_triag(rank_array, eigen_list)
    
    latex_str = triag_str_to_latex(triag_str,eigen_list)
    # Display the latex array
    display(Markdown(latex_str))
    
    
    
def dual_rank_widget():
    """
    Creates an interactive widget for multi_to_rank
    """
    im = widgets.interact_manual(dual_rank, 
                 rank_str_input = widgets.Textarea(value="(-2,-1,0,1,2),{2,4,4,4,2},{{2,3,3,2},{1,2,1},{1,1},{0}}", 
                                                   description = "Rank-Triangle"));
    im.widget.children[_sage_const_1 ].description = "Run Algorithm"
    im.widget.children[_sage_const_1 ].style.button_color = 'violet'
    
    
    
def quotient_triangle_table(mseg_string):
    """
    Create a table of quotient representations and associated rank triangles below a given multisegment
    """
    
    # Initialize the multisegment
    multi_seg = parse_mseg_string(mseg_string, True)
    
    # Compute the multisegments less than or equal to the inputed one and store them
    multi_seg.compute_less_thans()
    less_thans = multi_seg.get_less_thans()
    
    # Initialize the first row of the table
    latex_string = r"$\begin{array}{|c|c|}\hline \text{Unique Quotient} & \text{Rank Triangle} \\ \hline "
    
    
    # Add a row for each multisegment in the list containing its quotient and rank triangle
    for multi in less_thans:
        latex_string += r"Q(" + multi.__repr__()[_sage_const_1 :-_sage_const_1 ]+") & "
        array, e_list = rank_triag(multi)
        triag_str = array_to_triag(array, e_list)
        
        # Initialize int_list
        latex_str = triag_str_to_latex(triag_str, e_list, dollars = False)
        latex_string += latex_str + r" \\ \hline "
    
    # Display the final string
    latex_string += r"\end{array}$"
    display(Markdown(latex_string))
    
    
    
def quotient_table_widget():
    """
    Creates an interactive widget for quotient_triangle_table
    """
    im = widgets.interact_manual(quotient_triangle_table, 
                 mseg_string = widgets.Textarea(value="[[0,0],[-1,1]]", description = "Multisegment"));
    im.widget.children[_sage_const_1 ].description = "Run Algorithm"
    im.widget.children[_sage_const_1 ].style.button_color = 'violet'
    
    
    
def multi_double_matr(mseg_string, display_zeros = True,  print_multis = False):
    """
    Creates and displays the multiplicity matrix for a multiplicity free multisegment
    """
    # Initialize the multisegment
    multi_seg = parse_mseg_string(mseg_string)
    
    # Obtain its max
    multi_seg = multi_seg.get_max()
    
    # Compute min and max
    min_val = multi_seg.get_min_int() 
    max_val = multi_seg.get_max_int() 
    
    # Check that the support of the multisegment is multiplicity free
    if max_val - min_val != _sage_const_1 :
        print("Invalid support.")
        return
    
    # Record the number of occurrences of each basic segment
    min_occ = multi_seg.get_dict()[Segment(min_val,min_val)]
    max_occ = multi_seg.get_dict()[Segment(max_val,max_val)]
    highest_occ = min(max_occ,min_occ)
    # Compute the poset for the multisegment
    multi_seg.compute_less_thans()
    
    
    # Creates a sorted less_thans dictionary associated with the multisegment
    less_thans = multi_seg.get_less_thans()
    less_thans = dict(sorted(less_thans.items(), key = lambda item: len(item[_sage_const_1 ])))
    
    # Obtains the list of multisegments in the poset plus its size
    key_list = list(less_thans.keys())
    num_keys = len(less_thans.keys())
    
    # Obtain the relations between the multisegments
    rels = multi_seg.get_rel()
    
    # Creates an array with 1's along the diagonal of size num_keys
    multi_arr = np.diag(np.ones(num_keys), k =_sage_const_0 )
    # Adjust the value of the entries in the matrix so that they are 1 if the column is less than the row
    for i in range(num_keys):
        for j in range(num_keys):
            if j >= i:
                multi_arr[i,j] = int(math.comb(highest_occ-i,highest_occ-j))
    
    string_rows = []
    # Appends the row of values in the matrix to the latex string array
    for i in range(num_keys):
        latex_str_row = r"\pi_L(" + less_thans[key_list[i]] + ") & "
        for j in range(num_keys):
            if multi_arr[i,j] != _sage_const_0 :
                latex_str_row += r"\color{red}{" + str(int(multi_arr[i,j]))+r"}"
            elif display_zeros:
                latex_str_row += str(int(multi_arr[i,j]))
            
            if j != num_keys -_sage_const_1 :
                latex_str_row += r" & "
            else:
                latex_str_row += r"\\ "
        string_rows.append(latex_str_row)
    
    
    # Initialize a latex string for an array along with its first line being 
    # the irreducible subreps
    latex_str = r"$\begin{array}{c|" + num_keys*"c"+"} & "
    for i in range(num_keys):
        latex_str += r"L("+less_thans[key_list[i]]+r")"
        if i != num_keys -_sage_const_1 :
            latex_str += r" & "
        else:
            latex_str += r"\\ \hline"
    
    # Appends the row of values in the matrix to the latex string array
    for row in string_rows:
        latex_str += row
    latex_str += r"\end{array}$"
    # Display the latex array
    display(Markdown(latex_str))
    
    # Print the poset if requested
    if print_multis:
        multi_seg.print_poset()
        
        
        
def multi_double_matr_widget():
    """
    Creates an interactive widget for multi_free_matr
    """
    im = widgets.interact_manual(multi_double_matr, 
                     mseg_string = widgets.Textarea(value="[[0,0],[1,1]]", description = "Multisegment"),
                    display_zeros = widgets.Checkbox(value=True, description='Zeros',disabled=False, indent=True),
                    print_multis = widgets.Checkbox(value=False, description='Print Multisegments',disabled=False, indent=True))
    im.widget.children[_sage_const_3 ].description = "Run Algorithm"
    im.widget.children[_sage_const_3 ].style.button_color = 'violet'

